diff --git a/.cached_ipdb.json b/.cached_ipdb.json
--- a/.cached_ipdb.json
+++ b/.cached_ipdb.json
@@ -357,6 +357,12 @@
             "alternatives": null,
             "remote": "https://github.com/pulp-platform"
         },
+        {
+            "name": "edram_emu",
+            "path": "edram_emu",
+            "domain": null,
+            "alternatives": null
+        },
         {
             "name": "pulp_soc",
             "commit": "fpga",
diff --git a/fpga/pulpissimo-genesys2/fpga-settings.mk b/fpga/pulpissimo-genesys2/fpga-settings.mk
--- a/fpga/pulpissimo-genesys2/fpga-settings.mk
+++ b/fpga/pulpissimo-genesys2/fpga-settings.mk
@@ -5,7 +5,7 @@ export FC_CLK_PERIOD_NS=25
 export PER_CLK_PERIOD_NS=50
 export SLOW_CLK_PERIOD_NS=50
 #Must also change the localparam 'L2_BANK_SIZE' in pulp_soc.sv accordingly
-export INTERLEAVED_BANK_SIZE=28672
+export INTERLEAVED_BANK_SIZE=65536
 #Must also change the localparam 'L2_BANK_SIZE_PRI' in pulp_soc.sv accordingly
 export PRIVATE_BANK_SIZE=8192
 $(info Setting environment variables for $(BOARD) board)
diff --git a/fpga/pulpissimo-genesys2/rtl/pulp_clock_gating_xilinx.sv b/fpga/pulpissimo-genesys2/rtl/pulp_clock_gating_xilinx.sv
--- a/fpga/pulpissimo-genesys2/rtl/pulp_clock_gating_xilinx.sv
+++ b/fpga/pulpissimo-genesys2/rtl/pulp_clock_gating_xilinx.sv
@@ -16,6 +16,10 @@ module pulp_clock_gating
    output logic clk_o
    );
 
-   assign clk_o = clk_i;
-   
+  BUFGCE bufgce_i (
+    .I  ( clk_i            ),
+    .CE ( en_i | test_en_i ),
+    .O  ( clk_o            )
+  );
+
 endmodule
diff --git a/fpga/pulpissimo-zcu104/constraints/zcu104.xdc b/fpga/pulpissimo-zcu104/constraints/zcu104.xdc
--- a/fpga/pulpissimo-zcu104/constraints/zcu104.xdc
+++ b/fpga/pulpissimo-zcu104/constraints/zcu104.xdc
@@ -57,6 +57,12 @@ set_property ASYNC_REG true [get_cells i_pulpissimo/soc_domain_i/pulp_soc_i/soc_
 set_clock_groups -asynchronous -group [get_clocks -of_objects [get_pins i_pulpissimo/safe_domain_i/i_slow_clk_gen/slow_clk_o]] -group [get_clocks -of_objects [get_pins i_pulpissimo/soc_domain_i/pulp_soc_i/i_clk_rst_gen/i_fpga_clk_gen/soc_clk_o]]
 
 
+# Configure RAM blocks
+set_property RAM_STYLE ULTRA [get_cells i_pulpissimo/soc_domain_i/pulp_soc_i/edram_emu_wrap_i/edram_emu_i/ARR*/MEMARRAY_TS.MEMARRAY/RAM/ram*]
+set_property RAM_STYLE ULTRA [get_cells i_pulpissimo/soc_domain_i/pulp_soc_i/edram_emu_wrap_i/edram_emu_i/ARR*/MEMARRAY_TS.MOD_EV.MODIFIER/PRAM/ram*]
+set_property RAM_STYLE ULTRA [get_cells i_pulpissimo/soc_domain_i/pulp_soc_i/edram_emu_wrap_i/edram_emu_i/ARR*/MEMARRAY_TS.MOD_EV.MODIFIER/EVRAM/ram*]
+
+
 #############################################################
 #  _____ ____         _____      _   _   _                  #
 # |_   _/ __ \       / ____|    | | | | (_)                 #
diff --git a/fpga/pulpissimo-zcu104/fpga-settings.mk b/fpga/pulpissimo-zcu104/fpga-settings.mk
--- a/fpga/pulpissimo-zcu104/fpga-settings.mk
+++ b/fpga/pulpissimo-zcu104/fpga-settings.mk
@@ -5,7 +5,7 @@ export FC_CLK_PERIOD_NS=50
 export PER_CLK_PERIOD_NS=100
 export SLOW_CLK_PERIOD_NS=100
 #Must also change the localparam 'L2_BANK_SIZE' in pulp_soc.sv accordingly
-export INTERLEAVED_BANK_SIZE=28672
+export INTERLEAVED_BANK_SIZE=65536
 #Must also change the localparam 'L2_BANK_SIZE_PRI' in pulp_soc.sv accordingly
 export PRIVATE_BANK_SIZE=8192
 $(info Setting environment variables for $(BOARD) board)
diff --git a/fpga/pulpissimo-zcu104/rtl/pulp_clock_gating_xilinx.sv b/fpga/pulpissimo-zcu104/rtl/pulp_clock_gating_xilinx.sv
--- a/fpga/pulpissimo-zcu104/rtl/pulp_clock_gating_xilinx.sv
+++ b/fpga/pulpissimo-zcu104/rtl/pulp_clock_gating_xilinx.sv
@@ -16,6 +16,10 @@ module pulp_clock_gating
    output logic clk_o
    );
 
-   assign clk_o = clk_i;
-   
+  BUFGCE bufgce_i (
+    .I  ( clk_i            ),
+    .CE ( en_i | test_en_i ),
+    .O  ( clk_o            )
+  );
+
 endmodule
diff --git a/ips/L2_tcdm_hybrid_interco/RTL/XBAR_L2/XBAR_L2.sv b/ips/L2_tcdm_hybrid_interco/RTL/XBAR_L2/XBAR_L2.sv
--- a/ips/L2_tcdm_hybrid_interco/RTL/XBAR_L2/XBAR_L2.sv
+++ b/ips/L2_tcdm_hybrid_interco/RTL/XBAR_L2/XBAR_L2.sv
@@ -43,6 +43,7 @@ module XBAR_L2
    output  logic [N_SLAVE-1:0][DATA_WIDTH-1:0]             data_wdata_o,           // Data request Wrire data
    output  logic [N_SLAVE-1:0][BE_WIDTH-1:0]               data_be_o,              // Data request Byte enable
    output  logic [N_SLAVE-1:0][ID_WIDTH-1:0]               data_ID_o,
+   input   logic [N_SLAVE-1:0]                             data_gnt_i,
    // Resp --> From Mem
    input   logic [N_SLAVE-1:0][DATA_WIDTH-1:0]             data_r_rdata_i,         // Data Response DATA (For LOAD commands)
    input   logic [N_SLAVE-1:0]                             data_r_valid_i,         // Data Response: Command is Committed
@@ -134,7 +135,7 @@ module XBAR_L2
                       .data_be_o      ( data_be_o             [j] ),
                       .data_ID_o      ( data_ID_o             [j] ),
 
-                      .data_gnt_i     ( 1'b1                      ),
+                      .data_gnt_i     ( data_gnt_i            [j] ),
                       .data_r_valid_i ( data_r_valid_i        [j] ),
                       .data_r_ID_i    ( data_r_ID_i           [j] ),
                       // GEN VALID_SIGNALS in the response path
@@ -182,7 +183,7 @@ module XBAR_L2
                       .data_wdata_o      ( data_wdata_o      [j]                       ),
                       .data_be_o         ( data_be_o         [j]                       ),
                       .data_ID_o         ( data_ID_o         [j]                       ),
-                      .data_gnt_i        ( 1'b1                                        ),
+                      .data_gnt_i        ( data_gnt_i        [j]                       ),
 
                       .data_r_valid_i    ( data_r_valid_i    [j]                       ),
                       .data_r_ID_i       ( data_r_ID_i       [j]                       ),
diff --git a/ips/edram_emu/rtl/apb_slave.vhd b/ips/edram_emu/rtl/apb_slave.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/apb_slave.vhd
@@ -0,0 +1,123 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use ieee.std_logic_textio.all;
+use std.textio.all;
+use work.data_types.all;
+
+entity apb_slave is
+    generic(
+        AWIDTH     : natural;
+        DWIDTH     : natural;
+
+        NUM_PORTS  : natural;
+        START_ADDR : slv32_array;
+        END_ADDR   : slv32_array;
+
+        DEBUG      : boolean := false
+    );
+    port(
+        clk       : in  std_logic;
+        rst       : in  std_logic;
+
+        s_paddr   : in  std_logic_vector(AWIDTH - 1 downto 0);
+        s_pwdata  : in  std_logic_vector(DWIDTH - 1 downto 0);
+        s_pwrite  : in  std_logic;
+        s_psel    : in  std_logic;
+        s_penable : in  std_logic;
+        s_prdata  : out std_logic_vector(DWIDTH - 1 downto 0);
+        s_pready  : out std_logic;
+        s_pslverr : out std_logic;
+
+        m_en      : out std_logic_vector(NUM_PORTS - 1 downto 0);
+        m_rnw     : out std_logic;
+        m_addr    : out std_logic_vector(AWIDTH - 1 downto 0);
+        m_wdata   : out std_logic_vector(DWIDTH - 1 downto 0);
+        m_rdata   : in  std_logic_vector(NUM_PORTS * DWIDTH - 1 downto 0);
+        m_ack     : in  std_logic_vector(NUM_PORTS - 1 downto 0)
+    );
+end entity apb_slave;
+
+architecture rtl of apb_slave is
+    type state_type is (IDLE, ACTIVE);
+
+    signal state_reg, state_next : state_type;
+    signal sel                   : std_logic_vector(NUM_PORTS - 1 downto 0);
+begin
+    process(clk, rst) is
+        variable debug_buf : line;
+    begin
+        if rst = '1' then
+            state_reg <= IDLE;
+        elsif rising_edge(clk) then
+            if DEBUG and state_next = ACTIVE and s_pwrite = '0' then
+                write(debug_buf, string'("[APB ] read 0x"));
+                hwrite(debug_buf, s_paddr);
+                writeline(output, debug_buf);
+            end if;
+            if DEBUG and state_next = ACTIVE and s_pwrite = '1' then
+                write(debug_buf, string'("[APB ] write 0x"));
+                hwrite(debug_buf, s_paddr);
+                writeline(output, debug_buf);
+            end if;
+
+            state_reg <= state_next;
+        end if;
+    end process;
+
+    process(s_paddr) is
+    begin
+        sel <= (others => '0');
+        for i in 0 to NUM_PORTS - 1 loop
+            if unsigned(s_paddr) >= unsigned(START_ADDR(i)) and unsigned(s_paddr) <= unsigned(END_ADDR(i)) then
+                sel(i) <= '1';
+            end if;
+        end loop;
+    end process;
+
+    process(s_psel, s_penable, m_rdata, m_ack, state_reg, sel) is
+    begin
+        state_next <= state_reg;
+
+        s_prdata  <= (others => 'X');
+        s_pready  <= '0';
+        s_pslverr <= '0';
+        m_en      <= (others => '0');
+
+        case state_reg is
+            when IDLE =>
+                if s_psel = '1' and s_penable = '1' then
+                    s_pready  <= '1';
+                    s_pslverr <= '1';
+
+                    for i in 0 to NUM_PORTS - 1 loop
+                        if sel(i) = '1' then
+                            m_en(i)    <= '1';
+                            s_pready   <= '0';
+                            s_pslverr  <= '0';
+                            state_next <= ACTIVE;
+                        end if;
+                    end loop;
+                end if;
+
+            when ACTIVE =>
+                for i in 0 to NUM_PORTS - 1 loop
+                    if sel(i) = '1' then
+                        if m_ack(i) = '0' then
+                            m_en(i) <= '1';
+                        else
+                            s_prdata   <= m_rdata((i + 1) * DWIDTH - 1 downto i * DWIDTH);
+                            s_pready   <= '1';
+                            state_next <= IDLE;
+                        end if;
+                    end if;
+                end loop;
+
+        end case;
+    end process;
+
+    m_rnw   <= not s_pwrite;
+    m_addr  <= s_paddr;
+    m_wdata <= s_pwdata;
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/data_types.vhd b/ips/edram_emu/rtl/data_types.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/data_types.vhd
@@ -0,0 +1,6 @@
+library ieee;
+use ieee.std_logic_1164.all;
+
+package data_types is
+    type slv32_array is array(integer range <>) of std_logic_vector(31 downto 0);
+end package data_types;
diff --git a/ips/edram_emu/rtl/edram_array.vhd b/ips/edram_emu/rtl/edram_array.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/edram_array.vhd
@@ -0,0 +1,161 @@
+library ieee;
+use ieee.std_logic_1164.all;
+
+entity edram_array is
+    generic(
+        WORDSIZE_LOG   : natural;
+        ROWS_LOG       : natural;
+        TIMERSIZE      : natural;
+        TDIFFSIZE      : natural;
+        ACTSIZE        : natural;
+        NEVENTS_LOG    : natural;
+
+        MEMARRAY_MODEL : string;
+        MOD_MODEL      : string;
+        DEBUG          : boolean
+    );
+    port(
+        clk         : in  std_logic;
+        rst         : in  std_logic;
+
+        -- Memory port
+        ren         : in  std_logic;
+        rack        : out std_logic;
+        wen         : in  std_logic;
+        wack        : out std_logic;
+        raddr       : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        waddr       : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        rdata       : out std_logic_vector(2**WORDSIZE_LOG - 1 downto 0);
+        wdata       : in  std_logic_vector(2**WORDSIZE_LOG - 1 downto 0);
+
+        -- Pointer RAM write port
+        pram_wen    : in  std_logic;
+        pram_waddr  : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        pram_wdata  : in  std_logic_vector(2 * NEVENTS_LOG - 1 downto 0);
+
+        -- Event RAM write port
+        evram_wen   : in  std_logic;
+        evram_waddr : in  std_logic_vector(NEVENTS_LOG - 1 downto 0);
+        evram_wdata : in  std_logic_vector(ACTSIZE + TDIFFSIZE + WORDSIZE_LOG - 1 downto 0);
+
+        -- Control port
+        simts       : in  std_logic_vector(TIMERSIZE - 1 downto 0)
+    );
+end entity edram_array;
+
+architecture rtl of edram_array is
+    signal mod_en, mod_ack           : std_logic;
+    signal mod_addr                  : std_logic_vector(ROWS_LOG - 1 downto 0);
+    signal mod_tdiff                 : std_logic_vector(TDIFFSIZE - 1 downto 0);
+    signal mod_data_in, mod_data_out : std_logic_vector(2**WORDSIZE_LOG - 1 downto 0);
+begin
+    assert MEMARRAY_MODEL = "IDEAL" or MEMARRAY_MODEL = "TS" report "Invalid memarray model" severity failure;
+
+    MEMARRAY_BRAM : if MEMARRAY_MODEL = "IDEAL" generate
+        MEMARRAY : entity work.memarray_bram
+            generic map(
+                WORDSIZE_LOG => WORDSIZE_LOG,
+                ROWS_LOG     => ROWS_LOG,
+                DEBUG        => DEBUG
+            )
+            port map(
+                clk   => clk,
+                rst   => rst,
+                raddr => raddr,
+                ren   => ren,
+                rdata => rdata,
+                rack  => rack,
+                waddr => waddr,
+                wen   => wen,
+                wdata => wdata,
+                wack  => wack,
+                ready => open
+            );
+    end generate;
+
+    MEMARRAY_TS : if MEMARRAY_MODEL = "TS" generate
+        MEMARRAY : entity work.memarray_ts
+            generic map(
+                WORDSIZE_LOG => WORDSIZE_LOG,
+                ROWS_LOG     => ROWS_LOG,
+                TIMERSIZE    => TIMERSIZE,
+                TDIFFSIZE    => TDIFFSIZE,
+                DEBUG        => DEBUG
+            )
+            port map(
+                clk          => clk,
+                rst          => rst,
+                raddr        => raddr,
+                ren          => ren,
+                rdata        => rdata,
+                rack         => rack,
+                waddr        => waddr,
+                wen          => wen,
+                wdata        => wdata,
+                wack         => wack,
+                ready        => open,
+                mod_en       => mod_en,
+                mod_addr     => mod_addr,
+                mod_tdiff    => mod_tdiff,
+                mod_data_in  => mod_data_in,
+                mod_data_out => mod_data_out,
+                mod_ack      => mod_ack,
+                ts           => simts
+            );
+
+        assert MOD_MODEL = "SIMPLE" or MOD_MODEL = "EV" report "Invalid modifier model" severity failure;
+
+        MOD_SIMPLE : if MOD_MODEL = "SIMPLE" generate
+            MODIFIER : entity work.mod_simple
+                generic map(
+                    WORDSIZE_LOG => WORDSIZE_LOG,
+                    ROWS_LOG     => ROWS_LOG,
+                    TDIFFSIZE    => TDIFFSIZE,
+                    DEBUG        => DEBUG
+                )
+                port map(
+                    clk      => clk,
+                    rst      => rst,
+                    en       => mod_en,
+                    addr     => mod_addr,
+                    tdiff    => mod_tdiff,
+                    data_in  => mod_data_in,
+                    data_out => mod_data_out,
+                    ack      => mod_ack,
+                    ready    => open
+                );
+        end generate;
+
+        MOD_EV : if MOD_MODEL = "EV" generate
+            MODIFIER : entity work.mod_ev
+                generic map(
+                    WORDSIZE_LOG   => WORDSIZE_LOG,
+                    ROWS_LOG       => ROWS_LOG,
+                    TDIFFSIZE      => TDIFFSIZE,
+                    ACTSIZE        => ACTSIZE,
+                    NEVENTS_LOG    => NEVENTS_LOG,
+                    PRAM_INITFILE  => "",
+                    EVRAM_INITFILE => "",
+                    DEBUG          => DEBUG
+                )
+                port map(
+                    clk         => clk,
+                    rst         => rst,
+                    en          => mod_en,
+                    addr        => mod_addr,
+                    tdiff       => mod_tdiff,
+                    data_in     => mod_data_in,
+                    data_out    => mod_data_out,
+                    ack         => mod_ack,
+                    ready       => open,
+                    pram_wen    => pram_wen,
+                    pram_waddr  => pram_waddr,
+                    pram_wdata  => pram_wdata,
+                    evram_wen   => evram_wen,
+                    evram_waddr => evram_waddr,
+                    evram_wdata => evram_wdata,
+                    flip_strobe => open
+                );
+        end generate;
+    end generate;
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/edram_bank.vhd b/ips/edram_emu/rtl/edram_bank.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/edram_bank.vhd
@@ -0,0 +1,222 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+
+entity edram_bank is
+    generic(
+        AWIDTH       : natural;
+        DWIDTH_LOG   : natural;
+
+        WORDSIZE_LOG : natural;
+        ROWS_LOG     : natural;
+        ARRAYS_LOG   : natural;
+        TIMERSIZE    : natural;
+        SKIPSIZE     : natural;
+        RFSKIP_LOG   : natural;
+
+        DEBUG        : boolean
+    );
+    port(
+        clk        : in  std_logic;
+        clk_ext    : in  std_logic;
+        clk_ext_en : in  std_logic;
+        rst        : in  std_logic;
+
+        -- Control port
+        gen        : in  std_logic;
+        simts      : in  std_logic_vector(TIMERSIZE - 1 downto 0);
+        rfint      : in  std_logic_vector(TIMERSIZE - 1 downto 0);
+        tstop      : out std_logic_vector(2**ARRAYS_LOG - 1 downto 0);
+
+        -- Slave port
+        s_en       : in  std_logic;
+        s_rnw      : in  std_logic;
+        s_be       : in  std_logic_vector(2**DWIDTH_LOG / 8 - 1 downto 0);
+        s_addr     : in  std_logic_vector(AWIDTH - 1 downto 0);
+        s_wdata    : in  std_logic_vector(2**DWIDTH_LOG - 1 downto 0);
+        s_gnt      : out std_logic;
+        s_rdata    : out std_logic_vector(2**DWIDTH_LOG - 1 downto 0);
+
+        -- Master port
+        m_ren      : out std_logic_vector(2**ARRAYS_LOG - 1 downto 0);
+        m_rack     : in  std_logic_vector(2**ARRAYS_LOG - 1 downto 0);
+        m_wen      : out std_logic_vector(2**ARRAYS_LOG - 1 downto 0);
+        m_wack     : in  std_logic_vector(2**ARRAYS_LOG - 1 downto 0);
+        m_raddr    : out std_logic_vector(2**ARRAYS_LOG * ROWS_LOG - 1 downto 0);
+        m_waddr    : out std_logic_vector(2**ARRAYS_LOG * ROWS_LOG - 1 downto 0);
+        m_rdata    : in  std_logic_vector(2**ARRAYS_LOG * 2**WORDSIZE_LOG - 1 downto 0);
+        m_wdata    : out std_logic_vector(2**ARRAYS_LOG * 2**WORDSIZE_LOG - 1 downto 0)
+    );
+end entity edram_bank;
+
+architecture rtl of edram_bank is
+    constant WORDSIZE : natural := 2 ** WORDSIZE_LOG;
+    constant ARRAYS   : natural := 2 ** ARRAYS_LOG;
+
+    signal mem_en, mem_rnw, mem_gnt, mem_ack : std_logic;
+    signal mem_addr                          : std_logic_vector(AWIDTH - 1 downto 0);
+    signal mem_rdata, mem_wdata              : std_logic_vector(2**DWIDTH_LOG - 1 downto 0);
+    signal mem_be                            : std_logic_vector(2**DWIDTH_LOG / 8 - 1 downto 0);
+
+    signal cross_en, cross_rnw, cross_gnt, cross_ack : std_logic;
+    signal cross_addr                                : std_logic_vector(ARRAYS_LOG + ROWS_LOG - 1 downto 0);
+    signal cross_rdata, cross_wdata                  : std_logic_vector(WORDSIZE - 1 downto 0);
+
+    signal mux_en, mux_rnw, mux_gnt, mux_ack : std_logic;
+    signal mux_addr                          : std_logic_vector(ARRAYS_LOG + ROWS_LOG - 1 downto 0);
+    signal mux_rdata, mux_wdata              : std_logic_vector(WORDSIZE - 1 downto 0);
+
+    signal ctrl_ren, ctrl_rack, ctrl_wen, ctrl_wack, ctrl_ready : std_logic_vector(ARRAYS - 1 downto 0);
+    signal ctrl_raddr, ctrl_waddr                               : std_logic_vector(ROWS_LOG - 1 downto 0);
+    signal ctrl_rdata                                           : std_logic_vector(ARRAYS * WORDSIZE - 1 downto 0);
+    signal ctrl_wdata                                           : std_logic_vector(WORDSIZE - 1 downto 0);
+begin
+    cross_gnt <= gen and mux_gnt;
+
+    TCDM_SLAVE : entity work.tcdm_slave
+        generic map(
+            AWIDTH     => AWIDTH,
+            DWIDTH_LOG => DWIDTH_LOG
+        )
+        port map(
+            clk     => clk_ext,
+            rst     => rst,
+            s_en    => s_en,
+            s_rnw   => s_rnw,
+            s_be    => s_be,
+            s_addr  => s_addr,
+            s_wdata => s_wdata,
+            s_gnt   => s_gnt,
+            s_rdata => s_rdata,
+            m_en    => mem_en,
+            m_rnw   => mem_rnw,
+            m_addr  => mem_addr,
+            m_wdata => mem_wdata,
+            m_be    => mem_be,
+            m_rdata => mem_rdata,
+            m_gnt   => mem_gnt,
+            m_ack   => mem_ack
+        );
+
+    MEM_SLAVE : entity work.mem_slave
+        generic map(
+            AWIDTH       => AWIDTH,
+            DWIDTH_LOG   => DWIDTH_LOG,
+            WORDSIZE_LOG => WORDSIZE_LOG,
+            ROWS_LOG     => ARRAYS_LOG + ROWS_LOG,
+            DEBUG        => DEBUG
+        )
+        port map(
+            clk          => clk_ext,
+            rst          => rst,
+            en           => mem_en,
+            rnw          => mem_rnw,
+            addr         => mem_addr,
+            wdata        => mem_wdata,
+            be           => mem_be,
+            rdata        => mem_rdata,
+            gnt          => mem_gnt,
+            ack          => mem_ack,
+            m_en         => cross_en,
+            m_rnw        => cross_rnw,
+            m_addr       => cross_addr,
+            m_wdata      => cross_wdata,
+            m_rdata      => cross_rdata,
+            m_gnt        => cross_gnt,
+            m_ack        => cross_ack,
+            read_strobe  => open,
+            write_strobe => open
+        );
+
+    CROSSING : entity work.mem_crossing
+        generic map(
+            C_IPIC_AWIDTH => ARRAYS_LOG + ROWS_LOG,
+            C_IPIC_DWIDTH => WORDSIZE
+        )
+        port map(
+            clk      => clk,
+            rst      => rst,
+            s_clk_en => clk_ext_en,
+            s_en     => cross_en,
+            s_rnw    => cross_rnw,
+            s_addr   => cross_addr,
+            s_wdata  => cross_wdata,
+            s_rdata  => cross_rdata,
+            s_ack    => cross_ack,
+            m_en     => mux_en,
+            m_rnw    => mux_rnw,
+            m_addr   => mux_addr,
+            m_wdata  => mux_wdata,
+            m_rdata  => mux_rdata,
+            m_ack    => mux_ack
+        );
+
+    MUX : entity work.memmux
+        generic map(
+            CHANNELS_LOG => ARRAYS_LOG,
+            WORDSIZE_LOG => WORDSIZE_LOG,
+            S_ROWS_LOG   => ARRAYS_LOG + ROWS_LOG,
+            M_ROWS_LOG   => ROWS_LOG
+        )
+        port map(
+            clk     => clk,
+            rst     => rst,
+            s_en    => mux_en,
+            s_rnw   => mux_rnw,
+            s_addr  => mux_addr,
+            s_wdata => mux_wdata,
+            s_rdata => mux_rdata,
+            s_gnt   => mux_gnt,
+            s_ack   => mux_ack,
+            m_raddr => ctrl_raddr,
+            m_ren   => ctrl_ren,
+            m_rdata => ctrl_rdata,
+            m_rack  => ctrl_rack,
+            m_waddr => ctrl_waddr,
+            m_wen   => ctrl_wen,
+            m_wdata => ctrl_wdata,
+            m_wack  => ctrl_wack,
+            m_ready => ctrl_ready
+        );
+
+    CTRL_LOOP : for i in 0 to ARRAYS - 1 generate
+        MEMCTRL : entity work.memctrl
+            generic map(
+                WORDSIZE_LOG => WORDSIZE_LOG,
+                ROWS_LOG     => ROWS_LOG,
+                TIMERSIZE    => TIMERSIZE,
+                SKIPSIZE     => SKIPSIZE,
+                READWRITE    => true,
+                DEBUG        => DEBUG
+            )
+            port map(
+                clk            => clk,
+                rst            => rst,
+                s_raddr        => ctrl_raddr,
+                s_ren          => ctrl_ren(i),
+                s_rdata        => ctrl_rdata((i + 1) * WORDSIZE - 1 downto i * WORDSIZE),
+                s_rack         => ctrl_rack(i),
+                s_waddr        => ctrl_waddr,
+                s_wen          => ctrl_wen(i),
+                s_wdata        => ctrl_wdata,
+                s_wack         => ctrl_wack(i),
+                s_ready        => ctrl_ready(i),
+                m_raddr        => m_raddr((i + 1) * ROWS_LOG - 1 downto i * ROWS_LOG),
+                m_ren          => m_ren(i),
+                m_rdata        => m_rdata((i + 1) * WORDSIZE - 1 downto i * WORDSIZE),
+                m_rack         => m_rack(i),
+                m_waddr        => m_waddr((i + 1) * ROWS_LOG - 1 downto i * ROWS_LOG),
+                m_wen          => m_wen(i),
+                m_wdata        => m_wdata((i + 1) * WORDSIZE - 1 downto i * WORDSIZE),
+                m_wack         => m_wack(i),
+                m_ready        => '1',
+                ts             => simts,
+                rfint          => rfint,
+                rfskip_log     => std_logic_vector(to_unsigned(RFSKIP_LOG, SKIPSIZE)),
+                rfdist         => '1',
+                refresh_strobe => open,
+                stop           => tstop(i)
+            );
+    end generate;
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/edram_ctrl.vhd b/ips/edram_emu/rtl/edram_ctrl.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/edram_ctrl.vhd
@@ -0,0 +1,185 @@
+library ieee;
+use ieee.std_logic_1164.all;
+
+entity edram_ctrl is
+    generic(
+        APB_AWIDTH     : natural;
+        APB_DWIDTH_LOG : natural;
+
+        WORDSIZE_LOG   : natural;
+        ROWS_LOG       : natural;
+        TDIFFSIZE      : natural;
+        ACTSIZE        : natural;
+        NEVENTS_LOG    : natural;
+        NREGS          : natural;
+
+        DEBUG          : boolean := false
+    );
+    port(
+        clk         : in  std_logic;
+        clk_ext     : in  std_logic;
+        clk_ext_en  : in  std_logic;
+        rst         : in  std_logic;
+
+        paddr       : in  std_logic_vector(APB_AWIDTH - 1 downto 0);
+        pwdata      : in  std_logic_vector(2**APB_DWIDTH_LOG - 1 downto 0);
+        pwrite      : in  std_logic;
+        psel        : in  std_logic;
+        penable     : in  std_logic;
+        prdata      : out std_logic_vector(2**APB_DWIDTH_LOG - 1 downto 0);
+        pready      : out std_logic;
+        pslverr     : out std_logic;
+
+        regs_data   : in  std_logic_vector(NREGS * 2**APB_DWIDTH_LOG - 1 downto 0);
+        regs_wen    : out std_logic_vector(NREGS - 1 downto 0);
+        regs_wdata  : out std_logic_vector(2**APB_DWIDTH_LOG - 1 downto 0);
+
+        pram_wen    : out std_logic;
+        pram_waddr  : out std_logic_vector(ROWS_LOG - 1 downto 0);
+        pram_wdata  : out std_logic_vector(2 * NEVENTS_LOG - 1 downto 0);
+
+        evram_wen   : out std_logic;
+        evram_waddr : out std_logic_vector(NEVENTS_LOG - 1 downto 0);
+        evram_wdata : out std_logic_vector(ACTSIZE + TDIFFSIZE + WORDSIZE_LOG - 1 downto 0)
+    );
+end entity edram_ctrl;
+
+architecture rtl of edram_ctrl is
+    constant NPORTS     : natural := 3;
+    constant APB_DWIDTH : natural := 2 ** APB_DWIDTH_LOG;
+
+    signal cross_rnw           : std_logic;
+    signal cross_en, cross_ack : std_logic_vector(NPORTS - 1 downto 0);
+    signal cross_addr          : std_logic_vector(APB_AWIDTH - 1 downto 0);
+    signal cross_rdata         : std_logic_vector(NPORTS * APB_DWIDTH - 1 downto 0);
+    signal cross_wdata         : std_logic_vector(APB_DWIDTH - 1 downto 0);
+
+    signal apb_en, apb_rnw, apb_ack : std_logic_vector(NPORTS - 1 downto 0);
+    signal apb_addr                 : std_logic_vector(NPORTS * APB_AWIDTH - 1 downto 0);
+    signal apb_rdata, apb_wdata     : std_logic_vector(NPORTS * APB_DWIDTH - 1 downto 0);
+begin
+    APB_SLAVE : entity work.apb_slave
+        generic map(
+            AWIDTH     => APB_AWIDTH,
+            DWIDTH     => APB_DWIDTH,
+            NUM_PORTS  => NPORTS,
+            START_ADDR => (0 => X"0000_0000", 1 => X"0001_0000", 2 => X"0002_0000"),
+            END_ADDR   => (0 => X"0000_FFFF", 1 => X"0001_FFFF", 2 => X"0002_FFFF"),
+            DEBUG      => DEBUG
+        )
+        port map(
+            clk       => clk_ext,
+            rst       => rst,
+            s_paddr   => paddr,
+            s_pwdata  => pwdata,
+            s_pwrite  => pwrite,
+            s_psel    => psel,
+            s_penable => penable,
+            s_prdata  => prdata,
+            s_pready  => pready,
+            s_pslverr => pslverr,
+            m_en      => cross_en,
+            m_rnw     => cross_rnw,
+            m_addr    => cross_addr,
+            m_wdata   => cross_wdata,
+            m_rdata   => cross_rdata,
+            m_ack     => cross_ack
+        );
+
+    CROSSINGS : for i in 0 to NPORTS - 1 generate
+        CROSSING : entity work.mem_crossing
+            generic map(
+                C_IPIC_AWIDTH => APB_AWIDTH,
+                C_IPIC_DWIDTH => APB_DWIDTH
+            )
+            port map(
+                clk      => clk,
+                rst      => rst,
+                s_clk_en => clk_ext_en,
+                s_en     => cross_en(i),
+                s_rnw    => cross_rnw,
+                s_addr   => cross_addr,
+                s_wdata  => cross_wdata,
+                s_rdata  => cross_rdata((i + 1) * APB_DWIDTH - 1 downto i * APB_DWIDTH),
+                s_ack    => cross_ack(i),
+                m_en     => apb_en(i),
+                m_rnw    => apb_rnw(i),
+                m_addr   => apb_addr((i + 1) * APB_AWIDTH - 1 downto i * APB_AWIDTH),
+                m_wdata  => apb_wdata((i + 1) * APB_DWIDTH - 1 downto i * APB_DWIDTH),
+                m_rdata  => apb_rdata((i + 1) * APB_DWIDTH - 1 downto i * APB_DWIDTH),
+                m_ack    => apb_ack(i)
+            );
+    end generate;
+
+    REG_SLAVE : entity work.reg_slave
+        generic map(
+            NREGS      => NREGS,
+            AWIDTH     => APB_AWIDTH,
+            DWIDTH_LOG => APB_DWIDTH_LOG,
+            DEBUG      => DEBUG
+        )
+        port map(
+            clk        => clk,
+            rst        => rst,
+            en         => apb_en(0),
+            rnw        => apb_rnw(0),
+            addr       => apb_addr(APB_AWIDTH - 1 downto 0),
+            wdata      => apb_wdata(APB_DWIDTH - 1 downto 0),
+            rdata      => apb_rdata(APB_DWIDTH - 1 downto 0),
+            ack        => apb_ack(0),
+            regs_rdata => regs_data,
+            regs_wen   => regs_wen,
+            regs_wdata => regs_wdata
+        );
+
+    PRAM_SLAVE : entity work.mem_slave_simple
+        generic map(
+            AWIDTH     => APB_AWIDTH,
+            DWIDTH_LOG => APB_DWIDTH_LOG,
+            MEM_AWIDTH => ROWS_LOG,
+            MEM_DWIDTH => 2 * NEVENTS_LOG
+        )
+        port map(
+            clk     => clk,
+            rst     => rst,
+            en      => apb_en(1),
+            rnw     => apb_rnw(1),
+            addr    => apb_addr(2 * APB_AWIDTH - 1 downto APB_AWIDTH),
+            wdata   => apb_wdata(2 * APB_DWIDTH - 1 downto APB_DWIDTH),
+            be      => (others => '1'),
+            rdata   => apb_rdata(2 * APB_DWIDTH - 1 downto APB_DWIDTH),
+            ack     => apb_ack(1),
+            m_raddr => open,
+            m_ren   => open,
+            m_rdata => (others => 'X'),
+            m_waddr => pram_waddr,
+            m_wen   => pram_wen,
+            m_wdata => pram_wdata
+        );
+
+    EVRAM_SLAVE : entity work.mem_slave_simple
+        generic map(
+            AWIDTH     => APB_AWIDTH,
+            DWIDTH_LOG => APB_DWIDTH_LOG,
+            MEM_AWIDTH => NEVENTS_LOG,
+            MEM_DWIDTH => ACTSIZE + TDIFFSIZE + WORDSIZE_LOG
+        )
+        port map(
+            clk     => clk,
+            rst     => rst,
+            en      => apb_en(2),
+            rnw     => apb_rnw(2),
+            addr    => apb_addr(3 * APB_AWIDTH - 1 downto 2 * APB_AWIDTH),
+            wdata   => apb_wdata(3 * APB_DWIDTH - 1 downto 2 * APB_DWIDTH),
+            be      => (others => '1'),
+            rdata   => apb_rdata(3 * APB_DWIDTH - 1 downto 2 * APB_DWIDTH),
+            ack     => apb_ack(2),
+            m_raddr => open,
+            m_ren   => open,
+            m_rdata => (others => 'X'),
+            m_waddr => evram_waddr,
+            m_wen   => evram_wen,
+            m_wdata => evram_wdata
+        );
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/edram_emu.vhd b/ips/edram_emu/rtl/edram_emu.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/edram_emu.vhd
@@ -0,0 +1,297 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use work.data_types.all;
+
+entity edram_emu is
+    generic(
+        NBANKS         : natural;
+        AWIDTH         : natural;
+        DWIDTH_LOG     : natural;
+
+        APB_AWIDTH     : natural;
+        APB_DWIDTH_LOG : natural;
+
+        WORDSIZE_LOG   : natural := 5;
+        ROWS_LOG       : natural := 12;
+        TIMERSIZE      : natural := 32;
+        TDIFFSIZE      : natural := 15;
+        ACTSIZE        : natural := 2;
+        NEVENTS_LOG    : natural := 12;
+        SKIPSIZE       : natural := 3;
+        RFSKIP_LOG     : natural := 5;
+
+        MEMARRAY_MODEL : string  := "TS";
+        MOD_MODEL      : string  := "EV";
+        DEBUG          : boolean := false
+    );
+    port(
+        clk     : in  std_logic;
+        clk_ext : in  std_logic;
+        rst_ext : in  std_logic;
+
+        -- Control port
+        clk_en  : out std_logic;
+
+        -- Memory port
+        en      : in  std_logic_vector(NBANKS - 1 downto 0);
+        rnw     : in  std_logic_vector(NBANKS - 1 downto 0);
+        be      : in  std_logic_vector(NBANKS * 2**DWIDTH_LOG / 8 - 1 downto 0);
+        addr    : in  std_logic_vector(NBANKS * AWIDTH - 1 downto 0);
+        wdata   : in  std_logic_vector(NBANKS * 2**DWIDTH_LOG - 1 downto 0);
+        gnt     : out std_logic_vector(NBANKS - 1 downto 0);
+        rdata   : out std_logic_vector(NBANKS * 2**DWIDTH_LOG - 1 downto 0);
+
+        -- APB control port
+        paddr   : in  std_logic_vector(APB_AWIDTH - 1 downto 0);
+        pwdata  : in  std_logic_vector(2**APB_DWIDTH_LOG - 1 downto 0);
+        pwrite  : in  std_logic;
+        psel    : in  std_logic;
+        penable : in  std_logic;
+        prdata  : out std_logic_vector(2**APB_DWIDTH_LOG - 1 downto 0);
+        pready  : out std_logic;
+        pslverr : out std_logic
+    );
+end entity edram_emu;
+
+architecture rtl of edram_emu is
+    constant DWIDTH     : natural := 2 ** DWIDTH_LOG;
+    constant APB_DWIDTH : natural := 2 ** APB_DWIDTH_LOG;
+    constant WORDSIZE   : natural := 2 ** WORDSIZE_LOG;
+
+    constant ARRAYS_LOG : natural := AWIDTH - (WORDSIZE_LOG - 3) - ROWS_LOG;
+    constant ARRAYS     : natural := 2 ** ARRAYS_LOG;
+
+    constant NREGS : natural := 10;
+
+    signal rst        : std_logic;
+    signal ten, gen   : std_logic;
+    signal clk_ext_en : std_logic;
+    signal simts_en   : std_logic;
+
+    signal simts, rfint : std_logic_vector(TIMERSIZE - 1 downto 0);
+    signal mod_sel      : std_logic_vector(APB_DWIDTH - 1 downto 0);
+
+    type reg_array is array (integer range <>) of std_logic_vector(APB_DWIDTH - 1 downto 0);
+    signal regs : reg_array(0 to NREGS - 1);
+
+    signal sync_ready                                           : std_logic;
+    signal sync_ren, sync_rack, sync_wen, sync_wack, sync_tstop : std_logic_vector(NBANKS * ARRAYS - 1 downto 0);
+    signal sync_raddr, sync_waddr                               : std_logic_vector(NBANKS * ARRAYS * ROWS_LOG - 1 downto 0);
+    signal sync_rdata, sync_wdata                               : std_logic_vector(NBANKS * ARRAYS * WORDSIZE - 1 downto 0);
+
+    signal arr_ren, arr_rack, arr_wen, arr_wack : std_logic_vector(NBANKS * ARRAYS - 1 downto 0);
+    signal arr_raddr, arr_waddr                 : std_logic_vector(NBANKS * ARRAYS * ROWS_LOG - 1 downto 0);
+    signal arr_rdata, arr_wdata                 : std_logic_vector(NBANKS * ARRAYS * WORDSIZE - 1 downto 0);
+
+    signal regs_data  : std_logic_vector(NREGS * APB_DWIDTH - 1 downto 0);
+    signal regs_wen   : std_logic_vector(NREGS - 1 downto 0);
+    signal regs_wdata : std_logic_vector(APB_DWIDTH - 1 downto 0);
+
+    signal pram_wen   : std_logic;
+    signal pram_waddr : std_logic_vector(ROWS_LOG - 1 downto 0);
+    signal pram_wdata : std_logic_vector(2 * NEVENTS_LOG - 1 downto 0);
+
+    signal evram_wen   : std_logic;
+    signal evram_waddr : std_logic_vector(NEVENTS_LOG - 1 downto 0);
+    signal evram_wdata : std_logic_vector(ACTSIZE + TDIFFSIZE + WORDSIZE_LOG - 1 downto 0);
+
+    signal mod_pram_wen, mod_evram_wen : std_logic_vector(NBANKS * ARRAYS - 1 downto 0);
+begin
+    simts_en   <= ten and sync_ready;
+    clk_ext_en <= sync_ready or not gen;
+    clk_en     <= clk_ext_en;
+
+    BANKS : for i in 0 to NBANKS - 1 generate
+        BANK : entity work.edram_bank
+            generic map(
+                AWIDTH       => AWIDTH,
+                DWIDTH_LOG   => DWIDTH_LOG,
+                WORDSIZE_LOG => WORDSIZE_LOG,
+                ROWS_LOG     => ROWS_LOG,
+                ARRAYS_LOG   => ARRAYS_LOG,
+                TIMERSIZE    => TIMERSIZE,
+                SKIPSIZE     => SKIPSIZE,
+                RFSKIP_LOG   => RFSKIP_LOG,
+                DEBUG        => DEBUG
+            )
+            port map(
+                clk        => clk,
+                clk_ext    => clk_ext,
+                clk_ext_en => clk_ext_en,
+                rst        => rst,
+                gen        => gen,
+                simts      => simts,
+                rfint      => rfint,
+                tstop      => sync_tstop((i + 1) * ARRAYS - 1 downto i * ARRAYS),
+                s_en       => en(i),
+                s_rnw      => rnw(i),
+                s_be       => be((i + 1) * DWIDTH / 8 - 1 downto i * DWIDTH / 8),
+                s_addr     => addr((i + 1) * AWIDTH - 1 downto i * AWIDTH),
+                s_wdata    => wdata((i + 1) * DWIDTH - 1 downto i * DWIDTH),
+                s_gnt      => gnt(i),
+                s_rdata    => rdata((i + 1) * DWIDTH - 1 downto i * DWIDTH),
+                m_ren      => sync_ren((i + 1) * ARRAYS - 1 downto i * ARRAYS),
+                m_rack     => sync_rack((i + 1) * ARRAYS - 1 downto i * ARRAYS),
+                m_wen      => sync_wen((i + 1) * ARRAYS - 1 downto i * ARRAYS),
+                m_wack     => sync_wack((i + 1) * ARRAYS - 1 downto i * ARRAYS),
+                m_raddr    => sync_raddr((i + 1) * ARRAYS * ROWS_LOG - 1 downto i * ARRAYS * ROWS_LOG),
+                m_waddr    => sync_waddr((i + 1) * ARRAYS * ROWS_LOG - 1 downto i * ARRAYS * ROWS_LOG),
+                m_rdata    => sync_rdata((i + 1) * ARRAYS * WORDSIZE - 1 downto i * ARRAYS * WORDSIZE),
+                m_wdata    => sync_wdata((i + 1) * ARRAYS * WORDSIZE - 1 downto i * ARRAYS * WORDSIZE)
+            );
+    end generate;
+
+    SYNC : entity work.synchronizer
+        generic map(
+            CHANNELS     => NBANKS * ARRAYS,
+            WORDSIZE_LOG => WORDSIZE_LOG,
+            ROWS_LOG     => ROWS_LOG
+        )
+        port map(
+            clk     => clk,
+            rst     => rst,
+            s_raddr => sync_raddr,
+            s_ren   => sync_ren,
+            s_rdata => sync_rdata,
+            s_rack  => sync_rack,
+            s_waddr => sync_waddr,
+            s_wen   => sync_wen,
+            s_wdata => sync_wdata,
+            s_wack  => sync_wack,
+            s_tstop => sync_tstop,
+            s_ready => sync_ready,
+            m_raddr => arr_raddr,
+            m_ren   => arr_ren,
+            m_rdata => arr_rdata,
+            m_rack  => arr_rack,
+            m_waddr => arr_waddr,
+            m_wen   => arr_wen,
+            m_wdata => arr_wdata,
+            m_wack  => arr_wack
+        );
+
+    ARRS : for i in 0 to NBANKS * ARRAYS - 1 generate
+        mod_pram_wen(i)  <= pram_wen when unsigned(mod_sel) = 0 or unsigned(mod_sel) = to_unsigned(i + 1, APB_DWIDTH) else '0';
+        mod_evram_wen(i) <= evram_wen when unsigned(mod_sel) = 0 or unsigned(mod_sel) = to_unsigned(i + 1, APB_DWIDTH) else '0';
+
+        ARR : entity work.edram_array
+            generic map(
+                WORDSIZE_LOG   => WORDSIZE_LOG,
+                ROWS_LOG       => ROWS_LOG,
+                TIMERSIZE      => TIMERSIZE,
+                TDIFFSIZE      => TDIFFSIZE,
+                ACTSIZE        => ACTSIZE,
+                NEVENTS_LOG    => NEVENTS_LOG,
+                MEMARRAY_MODEL => MEMARRAY_MODEL,
+                MOD_MODEL      => MOD_MODEL,
+                DEBUG          => DEBUG
+            )
+            port map(
+                clk         => clk,
+                rst         => rst,
+                ren         => arr_ren(i),
+                rack        => arr_rack(i),
+                wen         => arr_wen(i),
+                wack        => arr_wack(i),
+                raddr       => arr_raddr((i + 1) * ROWS_LOG - 1 downto i * ROWS_LOG),
+                waddr       => arr_waddr((i + 1) * ROWS_LOG - 1 downto i * ROWS_LOG),
+                rdata       => arr_rdata((i + 1) * WORDSIZE - 1 downto i * WORDSIZE),
+                wdata       => arr_wdata((i + 1) * WORDSIZE - 1 downto i * WORDSIZE),
+                pram_wen    => mod_pram_wen(i),
+                pram_waddr  => pram_waddr,
+                pram_wdata  => pram_wdata,
+                evram_wen   => mod_evram_wen(i),
+                evram_waddr => evram_waddr,
+                evram_wdata => evram_wdata,
+                simts       => simts
+            );
+    end generate;
+
+    SIMTIMER : entity work.timer
+        generic map(
+            TIMERSIZE => TIMERSIZE
+        )
+        port map(
+            clk => clk,
+            rst => rst,
+            en  => simts_en,
+            ts  => simts
+        );
+
+    CTRL : entity work.edram_ctrl
+        generic map(
+            APB_AWIDTH     => APB_AWIDTH,
+            APB_DWIDTH_LOG => APB_DWIDTH_LOG,
+            WORDSIZE_LOG   => WORDSIZE_LOG,
+            ROWS_LOG       => ROWS_LOG,
+            TDIFFSIZE      => TDIFFSIZE,
+            ACTSIZE        => ACTSIZE,
+            NEVENTS_LOG    => NEVENTS_LOG,
+            NREGS          => NREGS,
+            DEBUG          => DEBUG
+        )
+        port map(
+            clk         => clk,
+            clk_ext     => clk_ext,
+            clk_ext_en  => clk_ext_en,
+            rst         => rst_ext,
+            paddr       => paddr,
+            pwdata      => pwdata,
+            pwrite      => pwrite,
+            psel        => psel,
+            penable     => penable,
+            prdata      => prdata,
+            pready      => pready,
+            pslverr     => pslverr,
+            regs_data   => regs_data,
+            regs_wen    => regs_wen,
+            regs_wdata  => regs_wdata,
+            pram_wen    => pram_wen,
+            pram_waddr  => pram_waddr,
+            pram_wdata  => pram_wdata,
+            evram_wen   => evram_wen,
+            evram_waddr => evram_waddr,
+            evram_wdata => evram_wdata
+        );
+
+    RESET : process(clk, rst_ext) is
+    begin
+        if rst_ext = '1' then
+            rst <= '1';
+        elsif rising_edge(clk) then
+            rst <= regs_wen(0) and regs_wdata(0);
+        end if;
+    end process;
+
+    REGS_WRITE : process(clk, rst) is
+    begin
+        if rst = '1' then
+            ten     <= '0';
+            gen     <= '0';
+            rfint   <= (others => '0');
+            mod_sel <= (others => '0');
+        elsif rising_edge(clk) then
+            if regs_wen(0) = '1' then
+                ten <= regs_wdata(1);
+                gen <= regs_wdata(3);
+            end if;
+            if regs_wen(1) = '1' then
+                rfint <= regs_wdata(rfint'range);
+            end if;
+            if regs_wen(9) = '1' then
+                mod_sel <= regs_wdata;
+            end if;
+        end if;
+    end process;
+
+    regs(0) <= (APB_DWIDTH - 1 downto 4 => '0') & gen & '0' & ten & '0';
+    regs(1) <= (APB_DWIDTH - 1 downto rfint'length => '0') & rfint;
+    regs(3) <= (APB_DWIDTH - 1 downto simts'length => '0') & simts;
+    regs(9) <= mod_sel;
+
+    REGS_READ : for i in 0 to NREGS - 1 generate
+        regs_data((i + 1) * APB_DWIDTH - 1 downto i * APB_DWIDTH) <= regs(i);
+    end generate;
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/bram.vhd b/ips/edram_emu/rtl/emu/bram.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/bram.vhd
@@ -0,0 +1,65 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use ieee.std_logic_textio.all;
+use std.textio.all;
+
+entity bram is
+    generic(
+        DWIDTH   : natural;
+        AWIDTH   : natural;
+        INITFILE : string := ""
+    );
+    port(
+        clk   : in  std_logic;
+        rst   : in  std_logic;
+        raddr : in  std_logic_vector(AWIDTH - 1 downto 0);
+        ren   : in  std_logic;
+        rdata : out std_logic_vector(DWIDTH - 1 downto 0);
+        waddr : in  std_logic_vector(AWIDTH - 1 downto 0);
+        wen   : in  std_logic;
+        wdata : in  std_logic_vector(DWIDTH - 1 downto 0)
+    );
+end entity bram;
+
+architecture imp of bram is
+    type ram_type is array (0 to 2**AWIDTH - 1) of std_logic_vector(DWIDTH - 1 downto 0);
+
+    impure function fromFile(fn : in string) return ram_type is
+        file f        : text open read_mode is fn;
+        variable l    : line;
+        variable data : ram_type;
+    begin
+        for i in data'range loop
+            readline(f, l);
+            read(l, data(i));
+        end loop;
+        return data;
+    end function;
+
+    impure function fromFileOpt(fn : in string) return ram_type is
+    begin
+        if fn /= "" and fn /= "null" then
+            return fromFile(fn);
+        else
+            return (ram_type'range => (DWIDTH - 1 downto 0 => 'X'));
+        end if;
+    end function;
+
+    signal ram : ram_type := fromFileOpt(INITFILE);
+begin
+    process(clk)
+    begin
+        if rising_edge(clk) then
+            rdata <= (others => 'X');
+            if rst = '0' then
+                if ren = '1' then
+                    rdata <= ram(to_integer(unsigned(raddr)));
+                end if;
+                if wen = '1' then
+                    ram(to_integer(unsigned(waddr))) <= wdata;
+                end if;
+            end if;
+        end if;
+    end process;
+end architecture imp;
diff --git a/ips/edram_emu/rtl/emu/mem_crossing.vhd b/ips/edram_emu/rtl/emu/mem_crossing.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/mem_crossing.vhd
@@ -0,0 +1,78 @@
+library ieee;
+use ieee.std_logic_1164.all;
+
+entity mem_crossing is
+    generic(
+        C_IPIC_AWIDTH : integer;
+        C_IPIC_DWIDTH : integer
+    );
+    port(
+        clk      : in  std_logic;
+        rst      : in  std_logic;
+
+        s_clk_en : in  std_logic;
+
+        -- Slave port
+        s_en     : in  std_logic;
+        s_rnw    : in  std_logic;
+        s_addr   : in  std_logic_vector(C_IPIC_AWIDTH - 1 downto 0);
+        s_wdata  : in  std_logic_vector(C_IPIC_DWIDTH - 1 downto 0);
+        s_rdata  : out std_logic_vector(C_IPIC_DWIDTH - 1 downto 0);
+        s_ack    : out std_logic;
+
+        -- Master port
+        m_en     : out std_logic;
+        m_rnw    : out std_logic;
+        m_addr   : out std_logic_vector(C_IPIC_AWIDTH - 1 downto 0);
+        m_wdata  : out std_logic_vector(C_IPIC_DWIDTH - 1 downto 0);
+        m_rdata  : in  std_logic_vector(C_IPIC_DWIDTH - 1 downto 0);
+        m_ack    : in  std_logic
+    );
+end entity mem_crossing;
+
+architecture rtl of mem_crossing is
+    signal ack_reg, ack_next     : std_logic;
+    signal rdata_reg, rdata_next : std_logic_vector(C_IPIC_DWIDTH - 1 downto 0);
+begin
+    process(clk, rst) is
+    begin
+        if rst = '1' then
+            ack_reg   <= '0';
+            rdata_reg <= (others => 'X');
+        elsif rising_edge(clk) then
+            ack_reg   <= ack_next;
+            rdata_reg <= rdata_next;
+        end if;
+    end process;
+
+    process(ack_reg, rdata_reg, s_clk_en, s_en, s_rnw, s_addr, s_wdata, m_ack, m_rdata) is
+    begin
+        ack_next   <= ack_reg;
+        rdata_next <= rdata_reg;
+
+        m_en    <= s_en;
+        m_rnw   <= s_rnw;
+        m_addr  <= s_addr;
+        m_wdata <= s_wdata;
+        s_ack   <= ack_reg;
+        s_rdata <= rdata_reg;
+
+        if m_ack = '1' then
+            s_ack      <= m_ack;
+            ack_next   <= m_ack;
+            s_rdata    <= m_rdata;
+            rdata_next <= m_rdata;
+        end if;
+
+        if s_clk_en = '1' then
+            ack_next   <= '0';
+            rdata_next <= (others => 'X');
+        elsif ack_reg = '1' or m_ack = '1' then
+            m_en    <= '0';
+            m_rnw   <= 'X';
+            m_addr  <= (others => 'X');
+            m_wdata <= (others => 'X');
+        end if;
+    end process;
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/mem_slave.vhd b/ips/edram_emu/rtl/emu/mem_slave.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/mem_slave.vhd
@@ -0,0 +1,214 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use ieee.std_logic_textio.all;
+use std.textio.all;
+
+entity mem_slave is
+    generic(
+        AWIDTH       : natural;
+        DWIDTH_LOG   : natural;
+
+        WORDSIZE_LOG : natural;
+        ROWS_LOG     : natural;
+        DEBUG        : boolean := false
+    );
+    port(
+        clk          : in  std_logic;
+        rst          : in  std_logic;
+
+        -- input port
+        en           : in  std_logic;
+        rnw          : in  std_logic;
+        addr         : in  std_logic_vector(AWIDTH - 1 downto 0);
+        wdata        : in  std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        be           : in  std_logic_vector(2 ** DWIDTH_LOG / 8 - 1 downto 0);
+        rdata        : out std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        gnt          : out std_logic;
+        ack          : out std_logic;
+
+        -- Master port
+        m_en         : out std_logic;
+        m_rnw        : out std_logic;
+        m_addr       : out std_logic_vector(ROWS_LOG - 1 downto 0);
+        m_wdata      : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        m_rdata      : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        m_gnt        : in  std_logic;
+        m_ack        : in  std_logic;
+
+        -- Control output port
+        read_strobe  : out std_logic;
+        write_strobe : out std_logic
+    );
+end mem_slave;
+
+architecture imp of mem_slave is
+    constant DWIDTH   : natural := 2 ** DWIDTH_LOG;
+    constant WORDSIZE : natural := 2 ** WORDSIZE_LOG;
+    type state_type is (IDLE, READ, WRITE_R, WRITE_W);
+
+    signal state_reg, state_next : state_type;
+    signal row_reg, row_next     : std_logic_vector(ROWS_LOG - 1 downto 0);
+    signal word_reg, word_next   : std_logic_vector(WORDSIZE_LOG - DWIDTH_LOG - 1 downto 0);
+    signal data_reg, data_next   : std_logic_vector(WORDSIZE - 1 downto 0);
+    signal wbus_reg, wbus_next   : std_logic_vector(WORDSIZE - 1 downto 0);
+    signal wmask_reg, wmask_next : std_logic_vector(WORDSIZE - 1 downto 0);
+begin
+    process(clk, rst) is
+        variable debug_buf : line;
+    begin
+        if rst = '1' then
+            state_reg <= IDLE;
+            row_reg   <= (others => 'X');
+            word_reg  <= (others => 'X');
+            data_reg  <= (others => 'X');
+            wbus_reg  <= (others => 'X');
+            wmask_reg <= (others => 'X');
+        elsif rising_edge(clk) then
+            if DEBUG and state_next = READ and (state_reg /= READ or m_ack = '1') then
+                write(debug_buf, string'("[MEM ] read 0x"));
+                hwrite(debug_buf, addr);
+                writeline(output, debug_buf);
+            end if;
+            if DEBUG and ((state_next = WRITE_R and state_reg /= WRITE_R) or (state_next = WRITE_W and state_reg /= WRITE_R and (state_reg /= WRITE_W or m_ack = '1'))) then
+                write(debug_buf, string'("[MEM ] write 0x"));
+                hwrite(debug_buf, addr);
+                writeline(output, debug_buf);
+            end if;
+
+            state_reg <= state_next;
+            row_reg   <= row_next;
+            word_reg  <= word_next;
+            data_reg  <= data_next;
+            wbus_reg  <= wbus_next;
+            wmask_reg <= wmask_next;
+        end if;
+    end process;
+
+    process(state_reg, row_reg, word_reg, data_reg, wbus_reg, wmask_reg, addr, be, en, rnw, wdata, m_rdata, m_gnt, m_ack) is
+        variable row  : std_logic_vector(ROWS_LOG - 1 downto 0);
+        variable word : std_logic_vector(WORDSIZE_LOG - DWIDTH_LOG - 1 downto 0);
+        variable done : std_logic;
+
+        variable word_int     : integer;
+        variable word_reg_int : integer;
+    begin
+        row  := addr(ROWS_LOG + WORDSIZE_LOG - 3 - 1 downto WORDSIZE_LOG - 3);
+        word := addr(WORDSIZE_LOG - 3 - 1 downto DWIDTH_LOG - 3);
+        done := '0';
+
+        word_int     := 0;
+        word_reg_int := 0;
+        if word'length /= 0 and not is_X(word) then
+            word_int := to_integer(unsigned(word));
+        end if;
+        if word_reg'length /= 0 and not is_X(word_reg) then
+            word_reg_int := to_integer(unsigned(word_reg));
+        end if;
+
+        state_next <= state_reg;
+        row_next   <= row_reg;
+        word_next  <= word_reg;
+        data_next  <= data_reg;
+        wbus_next  <= wbus_reg;
+        wmask_next <= wmask_reg;
+
+        gnt   <= '0';
+        rdata <= (others => 'X');
+
+        m_addr  <= (others => 'X');
+        m_en    <= '0';
+        m_rnw   <= 'X';
+        m_wdata <= (others => 'X');
+
+        read_strobe  <= '0';
+        write_strobe <= '0';
+
+        case state_reg is
+            when IDLE =>
+                -- see below
+
+            when READ =>
+                if m_ack = '0' then
+                    gnt    <= m_gnt;
+                    m_en   <= '1';
+                    m_rnw  <= '1';
+                    m_addr <= row_reg;
+                else
+                    done       := '1';
+                    rdata      <= m_rdata((word_reg_int + 1) * DWIDTH - 1 downto word_reg_int * DWIDTH);
+                    row_next   <= (others => 'X');
+                    word_next  <= (others => 'X');
+                    state_next <= IDLE;
+                end if;
+
+            when WRITE_R =>
+                m_en   <= '1';
+                m_addr <= row_reg;
+                if m_ack = '0' then
+                    m_rnw <= '1';
+                else
+                    m_rnw      <= '0';
+                    m_wdata    <= (m_rdata and not wmask_reg) or (wbus_reg and wmask_reg);
+                    data_next  <= m_rdata;
+                    state_next <= WRITE_W;
+                end if;
+
+            when WRITE_W =>
+                if m_ack = '0' then
+                    gnt     <= m_gnt;
+                    m_en    <= '1';
+                    m_rnw   <= '0';
+                    m_addr  <= row_reg;
+                    m_wdata <= (data_reg and not wmask_reg) or (wbus_reg and wmask_reg);
+                else
+                    done       := '1';
+                    row_next   <= (others => 'X');
+                    word_next  <= (others => 'X');
+                    wbus_next  <= (others => 'X');
+                    wmask_next <= (others => 'X');
+                    data_next  <= (others => 'X');
+                    state_next <= IDLE;
+                end if;
+
+        end case;
+
+        ack <= done;
+
+        if (state_reg = IDLE or done = '1') and en = '1' then
+            row_next  <= row;
+            word_next <= word;
+
+            m_en   <= '1';
+            m_addr <= row;
+
+            if rnw = '1' then
+                gnt         <= m_gnt;
+                m_rnw       <= '1';
+                state_next  <= READ;
+                read_strobe <= '1';
+            else
+                wbus_next                                                       <= (others => '0');
+                wbus_next((word_int + 1) * DWIDTH - 1 downto word_int * DWIDTH) <= wdata;
+
+                wmask_next <= (others => '0');
+                for i in be'range loop
+                    wmask_next(word_int * DWIDTH + 8 * (i + 1) - 1 downto word_int * DWIDTH + 8 * i) <= (others => be(i));
+                end loop;
+
+                if DWIDTH = WORDSIZE and be = (be'range => '1') then
+                    gnt        <= m_gnt;
+                    m_rnw      <= '0';
+                    m_wdata    <= wdata;
+                    data_next  <= (others => '0');
+                    state_next <= WRITE_W;
+                else
+                    m_rnw      <= '1';
+                    state_next <= WRITE_R;
+                end if;
+                write_strobe <= '1';
+            end if;
+        end if;
+    end process;
+
+end architecture imp;
diff --git a/ips/edram_emu/rtl/emu/mem_slave_simple.vhd b/ips/edram_emu/rtl/emu/mem_slave_simple.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/mem_slave_simple.vhd
@@ -0,0 +1,70 @@
+library ieee;
+use ieee.std_logic_1164.all;
+
+entity mem_slave_simple is
+    generic(
+        AWIDTH     : natural;
+        DWIDTH_LOG : natural;
+
+        MEM_AWIDTH : natural;
+        MEM_DWIDTH : natural
+    );
+    port(
+        clk     : in  std_logic;
+        rst     : in  std_logic;
+
+        -- input port
+        en      : in  std_logic;
+        rnw     : in  std_logic;
+        addr    : in  std_logic_vector(AWIDTH - 1 downto 0);
+        wdata   : in  std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        be      : in  std_logic_vector(2 ** DWIDTH_LOG / 8 - 1 downto 0);
+        rdata   : out std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        ack     : out std_logic;
+
+        -- Master port
+        m_raddr : out std_logic_vector(MEM_AWIDTH - 1 downto 0);
+        m_ren   : out std_logic;
+        m_rdata : in  std_logic_vector(MEM_DWIDTH - 1 downto 0);
+        m_waddr : out std_logic_vector(MEM_AWIDTH - 1 downto 0);
+        m_wen   : out std_logic;
+        m_wdata : out std_logic_vector(MEM_DWIDTH - 1 downto 0)
+    );
+end mem_slave_simple;
+
+architecture imp of mem_slave_simple is
+    signal en_int, ack_int : std_logic;
+    signal mem_row         : std_logic_vector(MEM_AWIDTH - 1 downto 0);
+begin
+    en_int <= en and not ack_int;
+
+    process(clk, rst) is
+    begin
+        if rst = '1' then
+            ack_int <= '0';
+        elsif rising_edge(clk) then
+            ack_int <= en_int;
+            if rnw = '0' then
+                assert be = (be'range => '1') report "Byte enable signal not supported" severity error;
+            end if;
+        end if;
+    end process;
+
+    mem_row <= addr(MEM_AWIDTH + DWIDTH_LOG - 3 - 1 downto DWIDTH_LOG - 3);
+    m_raddr <= mem_row;
+    m_waddr <= mem_row;
+
+    m_wdata <= wdata(m_wdata'range);
+
+    m_ren <= en_int and rnw;
+    m_wen <= en_int and not rnw;
+
+    ack <= ack_int;
+
+    process(m_rdata) is
+    begin
+        rdata                <= (others => '0');
+        rdata(m_rdata'range) <= m_rdata;
+    end process;
+
+end architecture imp;
diff --git a/ips/edram_emu/rtl/emu/memarray_bram.vhd b/ips/edram_emu/rtl/emu/memarray_bram.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/memarray_bram.vhd
@@ -0,0 +1,74 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use std.textio.all;
+
+entity memarray_bram is
+    generic(
+        WORDSIZE_LOG : natural;
+        ROWS_LOG     : natural;
+        DEBUG        : boolean := false
+    );
+    port(
+        clk   : in  std_logic;
+        rst   : in  std_logic;
+
+        -- Slave port
+        raddr : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        ren   : in  std_logic;
+        rdata : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        rack  : out std_logic;
+        waddr : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        wen   : in  std_logic;
+        wdata : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        wack  : out std_logic;
+        ready : out std_logic
+    );
+end entity memarray_bram;
+
+architecture rtl of memarray_bram is
+    constant WORDSIZE : natural := 2 ** WORDSIZE_LOG;
+begin
+    BRAM : entity work.bram
+        generic map(
+            DWIDTH   => WORDSIZE,
+            AWIDTH   => ROWS_LOG,
+            INITFILE => ""
+        )
+        port map(
+            clk   => clk,
+            rst   => rst,
+            raddr => raddr,
+            ren   => ren,
+            rdata => rdata,
+            waddr => waddr,
+            wen   => wen,
+            wdata => wdata
+        );
+
+    process(clk, rst) is
+        variable debug_buf : line;
+    begin
+        if rst = '1' then
+            rack <= '0';
+            wack <= '0';
+        elsif rising_edge(clk) then
+            if DEBUG and ren = '1' and not is_X(raddr) then
+                write(debug_buf, string'("[MARR] read word "));
+                write(debug_buf, to_integer(unsigned(raddr)));
+                writeline(output, debug_buf);
+            end if;
+            if DEBUG and wen = '1' and not is_X(waddr) then
+                write(debug_buf, string'("[MARR] write word "));
+                write(debug_buf, to_integer(unsigned(waddr)));
+                writeline(output, debug_buf);
+            end if;
+
+            rack <= ren;
+            wack <= wen;
+        end if;
+    end process;
+
+    ready <= '1';
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/memarray_ts.vhd b/ips/edram_emu/rtl/emu/memarray_ts.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/memarray_ts.vhd
@@ -0,0 +1,186 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use ieee.std_logic_textio.all;
+use std.textio.all;
+
+entity memarray_ts is
+    generic(
+        WORDSIZE_LOG : natural;
+        ROWS_LOG     : natural;
+        TIMERSIZE    : natural;
+        TDIFFSIZE    : natural;
+        DEBUG        : boolean := false
+    );
+    port(
+        clk          : in  std_logic;
+        rst          : in  std_logic;
+
+        -- Slave port
+        raddr        : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        ren          : in  std_logic;
+        rdata        : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        rack         : out std_logic;
+        waddr        : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        wen          : in  std_logic;
+        wdata        : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        wack         : out std_logic;
+        ready        : out std_logic;
+
+        -- Modifier port
+        mod_en       : out std_logic;
+        mod_addr     : out std_logic_vector(ROWS_LOG - 1 downto 0);
+        mod_tdiff    : out std_logic_vector(TDIFFSIZE - 1 downto 0);
+        mod_data_in  : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        mod_data_out : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        mod_ack      : in  std_logic;
+
+        -- Control input
+        ts           : in  std_logic_vector(TIMERSIZE - 1 downto 0)
+    );
+end entity memarray_ts;
+
+architecture rtl of memarray_ts is
+    constant WORDSIZE : natural := 2 ** WORDSIZE_LOG;
+    type state_type is (IDLE, READ, MODIFY);
+
+    signal state_reg, state_next                    : state_type;
+    signal ram_ren, ram_wen                         : std_logic;
+    signal ram_raddr, ram_waddr                     : std_logic_vector(ROWS_LOG - 1 downto 0);
+    signal ram_rdata, ram_wdata, write_data_ts      : std_logic_vector(WORDSIZE + TIMERSIZE - 1 downto 0);
+    signal wack_next                                : std_logic;
+    signal raddr_reg, raddr_next                    : std_logic_vector(ROWS_LOG - 1 downto 0);
+    signal read_data, read_data_reg, read_data_next : std_logic_vector(WORDSIZE - 1 downto 0);
+    signal tsdiff                                   : std_logic_vector(TIMERSIZE - 1 downto 0);
+    signal tdiff, tdiff_reg, tdiff_next             : std_logic_vector(TDIFFSIZE - 1 downto 0);
+begin
+    RAM : entity work.bram
+        generic map(
+            DWIDTH   => WORDSIZE + TIMERSIZE,
+            AWIDTH   => ROWS_LOG,
+            INITFILE => ""
+        )
+        port map(
+            clk   => clk,
+            rst   => rst,
+            raddr => ram_raddr,
+            ren   => ram_ren,
+            rdata => ram_rdata,
+            waddr => ram_waddr,
+            wen   => ram_wen,
+            wdata => ram_wdata
+        );
+
+    process(clk, rst) is
+        variable debug_buf : line;
+    begin
+        if rst = '1' then
+            state_reg     <= IDLE;
+            raddr_reg     <= (others => 'X');
+            read_data_reg <= (others => 'X');
+            tdiff_reg     <= (others => 'X');
+            wack          <= '0';
+        elsif rising_edge(clk) then
+            if DEBUG and state_next = READ then
+                write(debug_buf, string'("[MARR] read 0x"));
+                hwrite(debug_buf, raddr);
+                writeline(output, debug_buf);
+            end if;
+            if DEBUG and wack_next = '1' then
+                write(debug_buf, string'("[MARR] write 0x"));
+                hwrite(debug_buf, waddr);
+                writeline(output, debug_buf);
+            end if;
+
+            state_reg     <= state_next;
+            raddr_reg     <= raddr_next;
+            read_data_reg <= read_data_next;
+            tdiff_reg     <= tdiff_next;
+            wack          <= wack_next;
+        end if;
+    end process;
+
+    process(state_reg, raddr_reg, read_data_reg, tdiff_reg, write_data_ts, read_data, tdiff, raddr, ren, waddr, wen, mod_data_out, mod_ack) is
+        variable done : std_logic;
+    begin
+        done := '0';
+
+        state_next     <= state_reg;
+        raddr_next     <= raddr_reg;
+        read_data_next <= read_data_reg;
+        tdiff_next     <= tdiff_reg;
+        wack_next      <= '0';
+
+        rdata <= (others => 'X');
+        rack  <= '0';
+        ready <= '0';
+
+        mod_en      <= '0';
+        mod_addr    <= (others => 'X');
+        mod_tdiff   <= (others => 'X');
+        mod_data_in <= (others => 'X');
+
+        ram_ren   <= '0';
+        ram_wen   <= '0';
+        ram_raddr <= (others => 'X');
+        ram_waddr <= (others => 'X');
+        ram_wdata <= (others => 'X');
+
+        case state_reg is
+            when IDLE =>
+                -- see below
+
+            when READ =>
+                mod_en      <= '1';
+                mod_addr    <= raddr_reg;
+                mod_data_in <= read_data;
+                mod_tdiff   <= tdiff;
+
+                read_data_next <= read_data;
+                tdiff_next     <= tdiff;
+                state_next     <= MODIFY;
+
+            when MODIFY =>
+                if mod_ack = '0' then
+                    mod_en      <= '1';
+                    mod_addr    <= raddr_reg;
+                    mod_data_in <= read_data_reg;
+                    mod_tdiff   <= tdiff_reg;
+                else
+                    rdata <= mod_data_out;
+                    done  := '1';
+
+                    raddr_next     <= (others => 'X');
+                    read_data_next <= (others => 'X');
+                    tdiff_next     <= (others => 'X');
+                    state_next     <= IDLE;
+                end if;
+
+        end case;
+
+        rack <= done;
+
+        if state_reg = IDLE or done = '1' then
+            ready     <= '1';
+            ram_raddr <= raddr;
+            ram_ren   <= ren;
+            ram_waddr <= waddr;
+            ram_wen   <= wen;
+            ram_wdata <= write_data_ts;
+            wack_next <= wen;
+
+            if ren = '1' then
+                raddr_next <= raddr;
+                state_next <= READ;
+            end if;
+        end if;
+
+    end process;
+
+    write_data_ts <= wdata & ts;
+    read_data     <= ram_rdata(WORDSIZE + TIMERSIZE - 1 downto TIMERSIZE);
+    tsdiff        <= std_logic_vector(unsigned(ts) - unsigned(ram_rdata(TIMERSIZE - 1 downto 0)));
+    tdiff         <= tsdiff(TDIFFSIZE - 1 downto 0) when tsdiff(TIMERSIZE - 1 downto TDIFFSIZE) = (TIMERSIZE - 1 downto TDIFFSIZE => '0') else
+                     (others => '1');
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/memctrl.vhd b/ips/edram_emu/rtl/emu/memctrl.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/memctrl.vhd
@@ -0,0 +1,302 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use std.textio.all;
+
+entity memctrl is
+    generic(
+        WORDSIZE_LOG : natural;
+        ROWS_LOG     : natural;
+        TIMERSIZE    : natural;
+        SKIPSIZE     : natural;
+        READWRITE    : boolean;
+        DEBUG        : boolean := false
+    );
+    port(
+        clk            : in  std_logic;
+        rst            : in  std_logic;
+
+        -- Slave port
+        s_raddr        : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        s_ren          : in  std_logic;
+        s_rdata        : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        s_rack         : out std_logic;
+        s_waddr        : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        s_wen          : in  std_logic;
+        s_wdata        : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        s_wack         : out std_logic;
+        s_ready        : out std_logic;
+
+        -- Master port
+        m_raddr        : out std_logic_vector(ROWS_LOG - 1 downto 0);
+        m_ren          : out std_logic;
+        m_rdata        : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        m_rack         : in  std_logic;
+        m_waddr        : out std_logic_vector(ROWS_LOG - 1 downto 0);
+        m_wen          : out std_logic;
+        m_wdata        : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        m_wack         : in  std_logic;
+        m_ready        : in  std_logic;
+
+        -- Control input port
+        ts             : in  std_logic_vector(TIMERSIZE - 1 downto 0);
+        rfint          : in  std_logic_vector(TIMERSIZE - 1 downto 0);
+        rfskip_log     : in  std_logic_vector(SKIPSIZE - 1 downto 0);
+        rfdist         : in  std_logic;
+
+        -- Control output port
+        refresh_strobe : out std_logic;
+        stop           : out std_logic
+    );
+end entity memctrl;
+
+architecture rtl of memctrl is
+    constant WORDSIZE : natural := 2 ** WORDSIZE_LOG;
+    type state_type is (NORMAL, REFRESH);
+
+    signal state_reg, state_next     : state_type                               := NORMAL;
+    signal rfts_reg, rfts_next       : std_logic_vector(TIMERSIZE - 1 downto 0) := (others => '0');
+    signal counter_reg, counter_next : unsigned(ROWS_LOG + 1 - 1 downto 0)      := (others => '0');
+    signal data_reg, data_next       : std_logic_vector(WORDSIZE - 1 downto 0);
+    signal first_reg, first_next     : std_logic;
+    signal ren, ren_q                : std_logic;
+    signal wen, wen_q                : std_logic;
+
+    function do_stop(counter : unsigned(ROWS_LOG downto 0); first : std_logic; skip_log : std_logic_vector(SKIPSIZE - 1 downto 0); dist : std_logic) return std_logic is
+        variable result : std_logic;
+    begin
+        result := '1';
+        if unsigned(skip_log) = 0 then
+            result := '0';
+        elsif counter(ROWS_LOG) = '1' then
+            result := '0';
+        else
+            for i in 1 to 2 ** SKIPSIZE - 1 loop
+                if to_integer(unsigned(skip_log)) = i then
+                    if dist = '1' and first = '0' and counter(i - 1 downto 0) = (i - 1 downto 0 => '0') then
+                        result := '0';
+                    end if;
+                    if counter(i - 1 downto 0) = (i - 1 downto 0 => '1') then
+                        result := '0';
+                    end if;
+                end if;
+            end loop;
+        end if;
+        return result;
+    end function;
+
+    function is_last(counter : unsigned(ROWS_LOG downto 0); first : std_logic; skip_log : std_logic_vector(SKIPSIZE - 1 downto 0); dist : std_logic) return std_logic is
+        variable result : std_logic;
+    begin
+        result := '0';
+        if dist = '1' then
+            if first = '0' then
+                if unsigned(skip_log) = 0 then
+                    result := '1';
+                else
+                    for i in 1 to 2 ** SKIPSIZE - 1 loop
+                        if to_integer(unsigned(skip_log)) = i then
+                            if counter(i - 1 downto 0) = (i - 1 downto 0 => '0') then
+                                result := '1';
+                            end if;
+                        end if;
+                    end loop;
+                end if;
+            end if;
+        else
+            result := counter(ROWS_LOG);
+        end if;
+        return result;
+    end function;
+
+    function counter2addr(counter : unsigned(ROWS_LOG downto 0); skip_log : std_logic_vector(SKIPSIZE - 1 downto 0)) return std_logic_vector is
+        variable result : unsigned(ROWS_LOG - 1 downto 0);
+    begin
+        result := (others => 'X');
+        if unsigned(skip_log) = 0 then
+            result := counter(ROWS_LOG - 1 downto 0);
+        else
+            for i in 1 to 2 ** SKIPSIZE - 1 loop
+                if to_integer(unsigned(skip_log)) = i then
+                    result(ROWS_LOG - 1 downto ROWS_LOG - i) := counter(i - 1 downto 0);
+                    result(ROWS_LOG - i - 1 downto 0)        := counter(ROWS_LOG - 1 downto i);
+                end if;
+            end loop;
+        end if;
+        return std_logic_vector(result);
+    end function;
+begin
+    process(clk, rst) is
+        variable debug_buf : line;
+    begin
+        if rst = '1' then
+            state_reg   <= NORMAL;
+            rfts_reg    <= (others => '0');
+            counter_reg <= (others => '0');
+            data_reg    <= (others => 'X');
+            first_reg   <= '0';
+            ren_q       <= '0';
+            wen_q       <= '0';
+        elsif rising_edge(clk) then
+            if DEBUG and state_reg = NORMAL and state_next = REFRESH then
+                write(debug_buf, string'("[MCTL] start refresh"));
+                writeline(output, debug_buf);
+            end if;
+            if DEBUG and state_reg = REFRESH and state_next = NORMAL then
+                write(debug_buf, string'("[MCTL] end refresh"));
+                writeline(output, debug_buf);
+            end if;
+
+            state_reg   <= state_next;
+            rfts_reg    <= rfts_next;
+            counter_reg <= counter_next;
+            data_reg    <= data_next;
+            first_reg   <= first_next;
+            ren_q       <= ren;
+            wen_q       <= wen;
+        end if;
+    end process;
+
+    process(state_reg, rfts_reg, counter_reg, data_reg, first_reg, ren_q, wen_q, s_raddr, s_ren, s_waddr, s_wen, s_wdata, m_rdata, m_rack, m_wack, m_ready, ts, rfint, rfskip_log, rfdist) is
+        variable transparent : std_logic;
+    begin
+        transparent := '0';
+
+        state_next   <= state_reg;
+        rfts_next    <= rfts_reg;
+        counter_next <= counter_reg;
+        data_next    <= data_reg;
+        first_next   <= first_reg;
+        ren          <= ren_q;
+        wen          <= wen_q;
+
+        s_rdata <= (others => 'X');
+        s_rack  <= '0';
+        s_wack  <= '0';
+        s_ready <= '0';
+
+        m_raddr <= (others => 'X');
+        m_waddr <= (others => 'X');
+        m_wdata <= (others => 'X');
+
+        stop           <= '0';
+        refresh_strobe <= '0';
+
+        case state_reg is
+            when NORMAL =>
+                s_rdata <= m_rdata;
+                s_rack  <= m_rack;
+                s_wack  <= m_wack;
+
+                if m_rack = '1' then
+                    ren <= '0';
+                end if;
+                if m_wack = '1' then
+                    wen <= '0';
+                end if;
+
+                if unsigned(rfint) /= 0 and not is_X(ts) and unsigned(ts) >= unsigned(rfts_reg) + unsigned(rfint) then
+                    if (ren_q = '0' or m_rack = '1') and (wen_q = '0' or m_wack = '1') then
+                        if READWRITE then
+                            ren     <= '1';
+                            m_raddr <= counter2addr(counter_reg, rfskip_log);
+                        end if;
+
+                        rfts_next      <= ts;
+                        stop           <= do_stop(counter_reg, '1', rfskip_log, rfdist);
+                        refresh_strobe <= '1';
+                        first_next     <= '1';
+                        state_next     <= REFRESH;
+                    end if;
+                else
+                    transparent := '1';
+                end if;
+
+            when REFRESH =>
+                if READWRITE then
+                    if ren_q = '1' and m_rack = '0' then
+                        m_raddr <= counter2addr(counter_reg, rfskip_log);
+                    end if;
+                    if wen_q = '1' and m_wack = '0' then
+                        m_waddr <= counter2addr(counter_reg - 1, rfskip_log);
+                        m_wdata <= data_reg;
+                    end if;
+
+                    if m_rack = '1' then
+                        ren       <= '0';
+                        data_next <= m_rdata;
+                    end if;
+                    if m_wack = '1' then
+                        wen <= '0';
+                    end if;
+
+                    if (ren_q = '0' or m_rack = '1') and (wen_q = '0' or m_wack = '1') then
+                        if is_last(counter_reg, first_reg, rfskip_log, rfdist) = '1' then
+                            transparent := '1';
+                            data_next   <= (others => 'X');
+                            state_next  <= NORMAL;
+
+                            if counter_reg(ROWS_LOG) = '1' then
+                                counter_next <= (others => '0');
+                            end if;
+                        else
+                            wen     <= '1';
+                            m_waddr <= counter2addr(counter_reg, rfskip_log);
+                            if m_rack = '1' then
+                                m_wdata <= m_rdata;
+                            else
+                                m_wdata <= data_reg;
+                            end if;
+
+                            if is_last(counter_reg + 1, '0', rfskip_log, rfdist) = '0' then
+                                ren     <= '1';
+                                m_raddr <= counter2addr(counter_reg + 1, rfskip_log);
+                            end if;
+
+                            counter_next <= counter_reg + 1;
+                            first_next   <= '0';
+                            stop         <= do_stop(counter_reg + 1, '0', rfskip_log, rfdist);
+                        end if;
+                    else
+                        stop <= do_stop(counter_reg, first_reg, rfskip_log, rfdist);
+                    end if;
+                else
+                    if is_last(counter_reg, first_reg, rfskip_log, rfdist) = '1' then
+                        transparent := '1';
+                        data_next   <= (others => 'X');
+                        state_next  <= NORMAL;
+
+                        if counter_reg(ROWS_LOG) = '1' then
+                            counter_next <= (others => '0');
+                        end if;
+                    else
+                        counter_next <= counter_reg + 1;
+                        first_next   <= '0';
+                        stop         <= do_stop(counter_reg + 1, '0', rfskip_log, rfdist);
+                    end if;
+                end if;
+
+        end case;
+
+        if transparent = '1' then
+            m_raddr <= s_raddr;
+            m_waddr <= s_waddr;
+            m_wdata <= s_wdata;
+            s_ready <= m_ready;
+
+            if m_ready = '1' then
+                if s_ren = '1' then
+                    ren <= '1';
+                end if;
+                if s_wen = '1' then
+                    wen <= '1';
+                end if;
+            end if;
+        end if;
+
+    end process;
+
+    m_ren <= ren;
+    m_wen <= wen;
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/memmux.vhd b/ips/edram_emu/rtl/emu/memmux.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/memmux.vhd
@@ -0,0 +1,70 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+
+entity memmux is
+    generic(
+        CHANNELS_LOG : natural;
+        WORDSIZE_LOG : natural;
+        S_ROWS_LOG   : natural;
+        M_ROWS_LOG   : natural
+    );
+    port(
+        clk     : in  std_logic;
+        rst     : in  std_logic;
+
+        -- Slave port
+        s_en    : in  std_logic;
+        s_rnw   : in  std_logic;
+        s_addr  : in  std_logic_vector(S_ROWS_LOG - 1 downto 0);
+        s_wdata : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        s_rdata : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        s_gnt   : out std_logic;
+        s_ack   : out std_logic;
+
+        -- Master port
+        m_raddr : out std_logic_vector(M_ROWS_LOG - 1 downto 0);
+        m_ren   : out std_logic_vector((2 ** CHANNELS_LOG) - 1 downto 0);
+        m_rdata : in  std_logic_vector((2 ** CHANNELS_LOG) * (2 ** WORDSIZE_LOG) - 1 downto 0);
+        m_rack  : in  std_logic_vector((2 ** CHANNELS_LOG) - 1 downto 0);
+        m_waddr : out std_logic_vector(M_ROWS_LOG - 1 downto 0);
+        m_wen   : out std_logic_vector((2 ** CHANNELS_LOG) - 1 downto 0);
+        m_wdata : out std_logic_vector((2 ** WORDSIZE_LOG) - 1 downto 0);
+        m_wack  : in  std_logic_vector((2 ** CHANNELS_LOG) - 1 downto 0);
+        m_ready : in  std_logic_vector((2 ** CHANNELS_LOG) - 1 downto 0)
+    );
+end entity memmux;
+
+architecture rtl of memmux is
+    constant WORDSIZE : natural := 2 ** WORDSIZE_LOG;
+
+    signal channel, channel_q : unsigned(CHANNELS_LOG downto 0);
+begin
+    channel <= unsigned("0" & s_addr(S_ROWS_LOG - 1 downto S_ROWS_LOG - CHANNELS_LOG));
+
+    process(clk, rst) is
+    begin
+        if rst = '1' then
+            channel_q <= (others => '0');
+        elsif rising_edge(clk) then
+            channel_q <= channel;
+        end if;
+    end process;
+
+    process(channel, s_en, s_rnw) is
+    begin
+        m_ren                      <= (others => '0');
+        m_ren(to_integer(channel)) <= s_en and s_rnw;
+        m_wen                      <= (others => '0');
+        m_wen(to_integer(channel)) <= s_en and not s_rnw;
+    end process;
+
+    s_gnt   <= m_ready(to_integer(channel_q));
+    s_ack   <= m_rack(to_integer(channel_q)) or m_wack(to_integer(channel_q));
+    s_rdata <= m_rdata((to_integer(channel_q) + 1) * WORDSIZE - 1 downto to_integer(channel_q) * WORDSIZE);
+
+    m_raddr <= s_addr(M_ROWS_LOG - 1 downto 0);
+    m_waddr <= s_addr(M_ROWS_LOG - 1 downto 0);
+    m_wdata <= s_wdata;
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/mod_ev.vhd b/ips/edram_emu/rtl/emu/mod_ev.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/mod_ev.vhd
@@ -0,0 +1,248 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use ieee.std_logic_textio.all;
+use std.textio.all;
+
+entity mod_ev is
+    generic(
+        WORDSIZE_LOG   : natural;
+        ROWS_LOG       : natural;
+        TDIFFSIZE      : natural;
+        ACTSIZE        : natural;
+        NEVENTS_LOG    : natural;
+        PRAM_INITFILE  : string  := "";
+        EVRAM_INITFILE : string  := "";
+        DEBUG          : boolean := false
+    );
+    port(
+        clk         : in  std_logic;
+        rst         : in  std_logic;
+
+        -- Modifier port
+        en          : in  std_logic;
+        addr        : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        tdiff       : in  std_logic_vector(TDIFFSIZE - 1 downto 0);
+        data_in     : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        data_out    : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        ack         : out std_logic;
+        ready       : out std_logic;
+
+        -- Pointer ram write port
+        pram_wen    : in  std_logic;
+        pram_waddr  : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        pram_wdata  : in  std_logic_vector(2 * NEVENTS_LOG - 1 downto 0);
+
+        -- Event ram write port
+        evram_wen   : in  std_logic;
+        evram_waddr : in  std_logic_vector(NEVENTS_LOG - 1 downto 0);
+        evram_wdata : in  std_logic_vector(TDIFFSIZE + ACTSIZE + WORDSIZE_LOG - 1 downto 0);
+
+        -- Control output port
+        flip_strobe : out std_logic
+    );
+end entity mod_ev;
+
+architecture rtl of mod_ev is
+    constant WORDSIZE : natural := 2 ** WORDSIZE_LOG;
+    type state_type is (IDLE, PTR, EV);
+    type act_type is (NONE, DRT, DRT0, DRT1);
+
+    signal pram_ren         : std_logic;
+    signal pram_raddr       : std_logic_vector(ROWS_LOG - 1 downto 0);
+    signal pram_rdata       : std_logic_vector(2 * NEVENTS_LOG - 1 downto 0);
+    signal pram_ptr, pram_n : unsigned(NEVENTS_LOG - 1 downto 0);
+
+    signal evram_ren   : std_logic;
+    signal evram_raddr : std_logic_vector(NEVENTS_LOG - 1 downto 0);
+    signal evram_rdata : std_logic_vector(TDIFFSIZE + ACTSIZE + WORDSIZE_LOG - 1 downto 0);
+    signal evram_tdiff : std_logic_vector(TDIFFSIZE - 1 downto 0);
+    signal evram_act   : unsigned(ACTSIZE - 1 downto 0);
+    signal evram_bit   : unsigned(WORDSIZE_LOG - 1 downto 0);
+
+    signal state_reg, state_next            : state_type;
+    signal ptr_reg, ptr_next, n_reg, n_next : unsigned(NEVENTS_LOG - 1 downto 0);
+    signal data_reg, data_next              : std_logic_vector(WORDSIZE - 1 downto 0);
+    signal odata_reg, odata_next            : std_logic_vector(WORDSIZE - 1 downto 0);
+    signal tdiff_reg, tdiff_next            : std_logic_vector(TDIFFSIZE - 1 downto 0);
+
+    procedure apply_event(
+        signal oinput : in std_logic_vector(WORDSIZE - 1 downto 0);
+        signal input  : in std_logic_vector(WORDSIZE - 1 downto 0);
+        signal bit    : in unsigned(WORDSIZE_LOG - 1 downto 0);
+        signal act    : in unsigned(ACTSIZE - 1 downto 0);
+        signal output : out std_logic_vector(WORDSIZE - 1 downto 0);
+        signal strobe : out std_logic
+    ) is
+    begin
+        output <= input;
+        strobe <= '0';
+        if ((to_integer(act) = act_type'pos(DRT)) or
+            (to_integer(act) = act_type'pos(DRT0) and oinput(to_integer(bit)) = '0') or
+            (to_integer(act) = act_type'pos(DRT1) and oinput(to_integer(bit)) = '1')
+        ) then
+            output(to_integer(bit)) <= not oinput(to_integer(bit));
+            strobe                  <= '1';
+        end if;
+    end procedure;
+begin
+    PRAM : entity work.bram
+        generic map(
+            DWIDTH   => 2 * NEVENTS_LOG,
+            AWIDTH   => ROWS_LOG,
+            INITFILE => PRAM_INITFILE
+        )
+        port map(
+            clk   => clk,
+            rst   => rst,
+            raddr => pram_raddr,
+            ren   => pram_ren,
+            rdata => pram_rdata,
+            waddr => pram_waddr,
+            wen   => pram_wen,
+            wdata => pram_wdata
+        );
+
+    EVRAM : entity work.bram
+        generic map(
+            DWIDTH   => TDIFFSIZE + ACTSIZE + WORDSIZE_LOG,
+            AWIDTH   => NEVENTS_LOG,
+            INITFILE => EVRAM_INITFILE
+        )
+        port map(
+            clk   => clk,
+            rst   => rst,
+            raddr => evram_raddr,
+            ren   => evram_ren,
+            rdata => evram_rdata,
+            waddr => evram_waddr,
+            wen   => evram_wen,
+            wdata => evram_wdata
+        );
+
+    process(clk, rst) is
+        variable debug_buf : line;
+    begin
+        if rst = '1' then
+            state_reg <= IDLE;
+            ptr_reg   <= (others => 'X');
+            n_reg     <= (others => 'X');
+            data_reg  <= (others => 'X');
+            odata_reg <= (others => 'X');
+            tdiff_reg <= (others => 'X');
+        elsif rising_edge(clk) then
+            if DEBUG and state_next = PTR then
+                write(debug_buf, string'("[MOD ] modify 0x"));
+                hwrite(debug_buf, data_in);
+                write(debug_buf, string'(" addr=0x"));
+                hwrite(debug_buf, addr);
+                write(debug_buf, string'(" tdiff="));
+                write(debug_buf, to_integer(unsigned(tdiff)));
+                writeline(output, debug_buf);
+            end if;
+
+            state_reg <= state_next;
+            ptr_reg   <= ptr_next;
+            n_reg     <= n_next;
+            data_reg  <= data_next;
+            odata_reg <= odata_next;
+            tdiff_reg <= tdiff_next;
+        end if;
+    end process;
+
+    process(state_reg, ptr_reg, n_reg, data_reg, odata_reg, tdiff_reg, en, addr, tdiff, data_in, pram_ptr, pram_n, evram_tdiff, evram_act, evram_bit) is
+        variable done : std_logic;
+    begin
+        done := '0';
+
+        state_next <= state_reg;
+        ptr_next   <= ptr_reg;
+        n_next     <= n_reg;
+        data_next  <= data_reg;
+        odata_next <= odata_reg;
+        tdiff_next <= tdiff_reg;
+
+        data_out <= (others => 'X');
+        ack      <= '0';
+        ready    <= '0';
+
+        pram_ren    <= '0';
+        pram_raddr  <= (others => 'X');
+        evram_ren   <= '0';
+        evram_raddr <= (others => 'X');
+
+        flip_strobe <= '0';
+
+        case state_reg is
+            when IDLE =>
+                -- see below
+
+            when PTR =>
+                if not is_X(std_logic_vector(pram_n)) and pram_n /= (pram_n'range => '0') then
+                    evram_ren   <= '1';
+                    evram_raddr <= std_logic_vector(pram_ptr);
+                    data_next   <= odata_reg;
+                    ptr_next    <= pram_ptr + 1;
+                    n_next      <= pram_n - 1;
+                    state_next  <= EV;
+                else
+                    data_out <= odata_reg;
+
+                    odata_next <= (others => 'X');
+                    tdiff_next <= (others => 'X');
+                    done       := '1';
+                    state_next <= IDLE;
+                end if;
+
+            when EV =>
+                if n_reg /= (n_reg'range => '0') and evram_tdiff <= tdiff_reg then
+                    if not is_X(std_logic_vector(evram_bit)) then
+                        apply_event(odata_reg, data_reg, evram_bit, evram_act, data_next, flip_strobe);
+                    end if;
+
+                    evram_ren   <= '1';
+                    evram_raddr <= std_logic_vector(ptr_reg);
+                    ptr_next    <= ptr_reg + 1;
+                    n_next      <= n_reg - 1;
+                else
+                    data_out <= data_reg;
+                    if evram_tdiff <= tdiff_reg and not is_X(std_logic_vector(evram_bit)) then
+                        apply_event(odata_reg, data_reg, evram_bit, evram_act, data_out, flip_strobe);
+                    end if;
+
+                    data_next  <= (others => 'X');
+                    odata_next <= (others => 'X');
+                    tdiff_next <= (others => 'X');
+                    ptr_next   <= (others => 'X');
+                    n_next     <= (others => 'X');
+                    done       := '1';
+                    state_next <= IDLE;
+                end if;
+
+        end case;
+
+        ack <= done;
+
+        if state_reg = IDLE or done = '1' then
+            ready <= '1';
+
+            pram_ren   <= en;
+            pram_raddr <= addr;
+
+            if en = '1' then
+                odata_next <= data_in;
+                tdiff_next <= tdiff;
+                state_next <= PTR;
+            end if;
+        end if;
+
+    end process;
+
+    pram_ptr <= unsigned(pram_rdata(2 * NEVENTS_LOG - 1 downto NEVENTS_LOG));
+    pram_n   <= unsigned(pram_rdata(NEVENTS_LOG - 1 downto 0));
+
+    evram_tdiff <= evram_rdata(TDIFFSIZE + ACTSIZE + WORDSIZE_LOG - 1 downto ACTSIZE + WORDSIZE_LOG);
+    evram_act   <= unsigned(evram_rdata(ACTSIZE + WORDSIZE_LOG - 1 downto WORDSIZE_LOG));
+    evram_bit   <= unsigned(evram_rdata(WORDSIZE_LOG - 1 downto 0));
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/mod_simple.vhd b/ips/edram_emu/rtl/emu/mod_simple.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/mod_simple.vhd
@@ -0,0 +1,60 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use ieee.std_logic_textio.all;
+use std.textio.all;
+
+entity mod_simple is
+    generic(
+        WORDSIZE_LOG : natural;
+        ROWS_LOG     : natural;
+        TDIFFSIZE    : natural;
+        DEBUG        : boolean := false
+    );
+    port(
+        clk      : in  std_logic;
+        rst      : in  std_logic;
+
+        -- Modifier port
+        en       : in  std_logic;
+        addr     : in  std_logic_vector(ROWS_LOG - 1 downto 0);
+        tdiff    : in  std_logic_vector(TDIFFSIZE - 1 downto 0);
+        data_in  : in  std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        data_out : out std_logic_vector(2 ** WORDSIZE_LOG - 1 downto 0);
+        ack      : out std_logic;
+        ready    : out std_logic
+    );
+end entity mod_simple;
+
+architecture rtl of mod_simple is
+begin
+    process(clk, rst) is
+        variable debug_buf : line;
+    begin
+        if rst = '1' then
+            data_out <= (others => 'X');
+            ack      <= '0';
+        elsif rising_edge(clk) then
+            data_out <= (others => 'X');
+            ack      <= '0';
+
+            if en = '1' then
+                if DEBUG then
+                    write(debug_buf, string'("[MOD ] modify 0x"));
+                    hwrite(debug_buf, data_in);
+                    write(debug_buf, string'(" addr=0x"));
+                    hwrite(debug_buf, addr);
+                    write(debug_buf, string'(" tdiff="));
+                    write(debug_buf, to_integer(unsigned(tdiff)));
+                    writeline(output, debug_buf);
+                end if;
+
+                data_out <= data_in;
+                ack      <= '1';
+            end if;
+        end if;
+    end process;
+
+    ready <= '1';
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/synchronizer.vhd b/ips/edram_emu/rtl/emu/synchronizer.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/synchronizer.vhd
@@ -0,0 +1,114 @@
+library ieee;
+use ieee.std_logic_1164.all;
+
+entity synchronizer is
+    generic(
+        CHANNELS     : natural;
+        WORDSIZE_LOG : natural;
+        ROWS_LOG     : natural
+    );
+    port(
+        clk     : in  std_logic;
+        rst     : in  std_logic;
+
+        -- Slave port
+        s_raddr : in  std_logic_vector(CHANNELS * ROWS_LOG - 1 downto 0);
+        s_ren   : in  std_logic_vector(CHANNELS - 1 downto 0);
+        s_rdata : out std_logic_vector(CHANNELS * (2 ** WORDSIZE_LOG) - 1 downto 0);
+        s_rack  : out std_logic_vector(CHANNELS - 1 downto 0);
+        s_waddr : in  std_logic_vector(CHANNELS * ROWS_LOG - 1 downto 0);
+        s_wen   : in  std_logic_vector(CHANNELS - 1 downto 0);
+        s_wdata : in  std_logic_vector(CHANNELS * (2 ** WORDSIZE_LOG) - 1 downto 0);
+        s_wack  : out std_logic_vector(CHANNELS - 1 downto 0);
+        s_tstop : in  std_logic_vector(CHANNELS - 1 downto 0);
+        s_ready : out std_logic;
+
+        -- Master port
+        m_raddr : out std_logic_vector(CHANNELS * ROWS_LOG - 1 downto 0);
+        m_ren   : out std_logic_vector(CHANNELS - 1 downto 0);
+        m_rdata : in  std_logic_vector(CHANNELS * (2 ** WORDSIZE_LOG) - 1 downto 0);
+        m_rack  : in  std_logic_vector(CHANNELS - 1 downto 0);
+        m_waddr : out std_logic_vector(CHANNELS * ROWS_LOG - 1 downto 0);
+        m_wen   : out std_logic_vector(CHANNELS - 1 downto 0);
+        m_wdata : out std_logic_vector(CHANNELS * (2 ** WORDSIZE_LOG) - 1 downto 0);
+        m_wack  : in  std_logic_vector(CHANNELS - 1 downto 0)
+    );
+end entity synchronizer;
+
+architecture rtl of synchronizer is
+    constant WORDSIZE : natural := 2 ** WORDSIZE_LOG;
+
+    signal tstop_q                                  : std_logic_vector(CHANNELS - 1 downto 0);
+    signal rack_reg, rack_next, wack_reg, wack_next : std_logic_vector(CHANNELS - 1 downto 0);
+    signal ren_reg, ren_next, wen_reg, wen_next     : std_logic_vector(CHANNELS - 1 downto 0);
+    signal rdata_reg, rdata_next                    : std_logic_vector(CHANNELS * (2 ** WORDSIZE_LOG) - 1 downto 0);
+begin
+    process(clk, rst) is
+    begin
+        if rst = '1' then
+            tstop_q   <= (others => '0');
+            rack_reg  <= (others => '0');
+            wack_reg  <= (others => '0');
+            ren_reg   <= (others => '0');
+            wen_reg   <= (others => '0');
+            rdata_reg <= (others => 'X');
+        elsif rising_edge(clk) then
+            tstop_q   <= s_tstop;
+            rack_reg  <= rack_next;
+            wack_reg  <= wack_next;
+            ren_reg   <= ren_next;
+            wen_reg   <= wen_next;
+            rdata_reg <= rdata_next;
+        end if;
+    end process;
+
+    process(tstop_q, rack_reg, wack_reg, ren_reg, wen_reg, rdata_reg, s_ren, s_wen, m_rack, m_rdata, m_wack) is
+        variable ready : boolean;
+    begin
+        rack_next  <= rack_reg;
+        wack_next  <= wack_reg;
+        rdata_next <= rdata_reg;
+
+        ren_next <= ren_reg and not m_rack;
+        wen_next <= wen_reg and not m_wack;
+
+        s_rack  <= (others => '0');
+        s_wack  <= (others => '0');
+        s_ready <= '0';
+        s_rdata <= rdata_reg;
+
+        ready := (tstop_q = (tstop_q'range => '0') and (ren_reg and not m_rack) = (ren_reg'range => '0') and (wen_reg and not m_wack) = (wen_reg'range => '0'));
+
+        for i in 0 to CHANNELS - 1 loop
+            if m_rack(i) = '1' then
+                s_rdata((i + 1) * WORDSIZE - 1 downto i * WORDSIZE)    <= m_rdata((i + 1) * WORDSIZE - 1 downto i * WORDSIZE);
+                rdata_next((i + 1) * WORDSIZE - 1 downto i * WORDSIZE) <= m_rdata((i + 1) * WORDSIZE - 1 downto i * WORDSIZE);
+            end if;
+
+            if ready or (tstop_q(i) = '1' and (ren_reg(i) = '0' or m_rack(i) = '1') and (wen_reg(i) = '0' or m_wack(i) = '1')) then
+                s_rack(i) <= rack_reg(i);
+                s_wack(i) <= wack_reg(i);
+
+                rack_next(i) <= s_ren(i);
+                ren_next(i)  <= s_ren(i);
+                wack_next(i) <= s_wen(i);
+                wen_next(i)  <= s_wen(i);
+
+                rdata_next((i + 1) * WORDSIZE - 1 downto i * WORDSIZE) <= (others => 'X');
+            end if;
+        end loop;
+
+        if ready then
+            s_ready <= '1';
+        else
+            s_ready <= '0';
+        end if;
+    end process;
+
+    m_ren   <= ren_next;
+    m_wen   <= wen_next;
+    m_raddr <= s_raddr;
+    m_waddr <= s_waddr;
+    m_wdata <= s_wdata;
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/emu/timer.vhd b/ips/edram_emu/rtl/emu/timer.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/emu/timer.vhd
@@ -0,0 +1,32 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+
+entity timer is
+    generic(
+        TIMERSIZE : natural
+    );
+    port(
+        clk : in  std_logic;
+        rst : in  std_logic;
+        en  : in  std_logic;
+        ts  : out std_logic_vector(TIMERSIZE - 1 downto 0)
+    );
+end entity timer;
+
+architecture rtl of timer is
+    signal timer : unsigned(TIMERSIZE - 1 downto 0);
+begin
+    process(clk, rst) is
+    begin
+        if rst = '1' then
+            timer <= (others => '0');
+        elsif rising_edge(clk) then
+            if en = '1' then
+                timer <= timer + 1;
+            end if;
+        end if;
+    end process;
+
+    ts <= std_logic_vector(timer);
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/reg_slave.vhd b/ips/edram_emu/rtl/reg_slave.vhd
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/rtl/reg_slave.vhd
@@ -0,0 +1,82 @@
+library ieee;
+use ieee.std_logic_1164.all;
+use ieee.numeric_std.all;
+use std.textio.all;
+
+entity reg_slave is
+    generic(
+        NREGS      : natural;
+        AWIDTH     : natural;
+        DWIDTH_LOG : natural;
+        DEBUG      : boolean := false
+    );
+    port(
+        clk        : in  std_logic;
+        rst        : in  std_logic;
+
+        en         : in  std_logic;
+        rnw        : in  std_logic;
+        addr       : in  std_logic_vector(AWIDTH - 1 downto 0);
+        wdata      : in  std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        rdata      : out std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        ack        : out std_logic;
+
+        regs_rdata : in  std_logic_vector(NREGS * 2 ** DWIDTH_LOG - 1 downto 0);
+        regs_wen   : out std_logic_vector(NREGS - 1 downto 0);
+        regs_wdata : out std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0)
+    );
+end entity reg_slave;
+
+architecture rtl of reg_slave is
+    constant DWIDTH : natural := 2 ** DWIDTH_LOG;
+
+    signal reg        : std_logic_vector(AWIDTH - (DWIDTH_LOG - 3) - 1 downto 0);
+    signal rdata_next : std_logic_vector(rdata'range);
+begin
+
+    reg <= addr(AWIDTH - 1 downto DWIDTH_LOG - 3);
+
+    process(clk, rst) is
+        variable debug_buf : line;
+    begin
+        if rst = '1' then
+            ack   <= '0';
+            rdata <= (others => 'X');
+        elsif rising_edge(clk) then
+            if DEBUG and en = '1' and rnw = '1' then
+                write(debug_buf, string'("[REG ] read reg "));
+                write(debug_buf, to_integer(unsigned(reg)));
+                writeline(output, debug_buf);
+            end if;
+            if DEBUG and en = '1' and rnw = '0' then
+                write(debug_buf, string'("[REG ] write reg "));
+                write(debug_buf, to_integer(unsigned(reg)));
+                writeline(output, debug_buf);
+            end if;
+
+            ack   <= en;
+            rdata <= rdata_next;
+        end if;
+    end process;
+
+    process(en, rnw, reg, regs_rdata) is
+    begin
+        regs_wen   <= (others => '0');
+        rdata_next <= (others => 'X');
+
+        if en = '1' then
+            for i in 0 to NREGS - 1 loop
+                if to_integer(unsigned(reg)) = i then
+                    if rnw = '0' then
+                        regs_wen(i) <= '1';
+                    else
+                        rdata_next <= regs_rdata((i + 1) * DWIDTH - 1 downto i * DWIDTH);
+                    end if;
+                end if;
+            end loop;
+        end if;
+    end process;
+
+    regs_wdata <= wdata;
+
+end architecture rtl;
diff --git a/ips/edram_emu/rtl/tcdm_slave.vhd b/ips/edram_emu/rtl/tcdm_slave.vhd
new file mode 100755
--- /dev/null
+++ b/ips/edram_emu/rtl/tcdm_slave.vhd
@@ -0,0 +1,77 @@
+library ieee;
+use ieee.std_logic_1164.all;
+
+entity tcdm_slave is
+    generic(
+        AWIDTH     : natural;
+        DWIDTH_LOG : natural
+    );
+    port(
+        clk     : in  std_logic;
+        rst     : in  std_logic;
+
+        -- Slave port
+        s_en    : in  std_logic;
+        s_rnw   : in  std_logic;
+        s_be    : in  std_logic_vector(2 ** DWIDTH_LOG / 8 - 1 downto 0);
+        s_addr  : in  std_logic_vector(AWIDTH - 1 downto 0);
+        s_wdata : in  std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        s_gnt   : out std_logic;
+        s_rdata : out std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+
+        -- Master port
+        m_en    : out std_logic;
+        m_rnw   : out std_logic;
+        m_addr  : out std_logic_vector(AWIDTH - 1 downto 0);
+        m_wdata : out std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        m_be    : out std_logic_vector(2 ** DWIDTH_LOG / 8 - 1 downto 0);
+        m_rdata : in  std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+        m_gnt   : in  std_logic;
+        m_ack   : in  std_logic
+    );
+end entity tcdm_slave;
+
+architecture rtl of tcdm_slave is
+    signal gnt_q                 : std_logic;
+    signal rdata_reg, rdata_next : std_logic_vector(2 ** DWIDTH_LOG - 1 downto 0);
+begin
+    process(clk, rst) is
+    begin
+        if rst = '1' then
+            gnt_q     <= '0';
+            rdata_reg <= (others => 'X');
+        elsif rising_edge(clk) then
+            if gnt_q = '1' then
+                assert m_ack = '1' report "Gnt not followed by ack" severity error;
+            end if;
+
+            gnt_q     <= m_gnt;
+            rdata_reg <= rdata_next;
+        end if;
+    end process;
+
+    process(rdata_reg, gnt_q, s_en, m_rdata, m_gnt, m_ack) is
+    begin
+        rdata_next <= (others => 'X');
+
+        m_en    <= s_en;
+        s_gnt   <= m_gnt;
+        s_rdata <= rdata_reg;
+
+        if m_ack = '1' then
+            if gnt_q = '1' then
+                s_rdata <= m_rdata;
+            else
+                m_en       <= '0';
+                s_gnt      <= '1';
+                rdata_next <= m_rdata;
+            end if;
+        end if;
+    end process;
+
+    m_rnw   <= s_rnw;
+    m_addr  <= s_addr;
+    m_wdata <= s_wdata;
+    m_be    <= s_be;
+
+end architecture rtl;
diff --git a/ips/edram_emu/src_files.yml b/ips/edram_emu/src_files.yml
new file mode 100644
--- /dev/null
+++ b/ips/edram_emu/src_files.yml
@@ -0,0 +1,23 @@
+edram_emu:
+  files: [
+    rtl/emu/bram.vhd,
+    rtl/emu/memarray_bram.vhd,
+    rtl/emu/memarray_ts.vhd,
+    rtl/emu/memctrl.vhd,
+    rtl/emu/memmux.vhd,
+    rtl/emu/mem_crossing.vhd,
+    rtl/emu/mem_slave.vhd,
+    rtl/emu/mem_slave_simple.vhd,
+    rtl/emu/mod_ev.vhd,
+    rtl/emu/mod_simple.vhd,
+    rtl/emu/synchronizer.vhd,
+    rtl/emu/timer.vhd,
+    rtl/data_types.vhd,
+    rtl/apb_slave.vhd,
+    rtl/reg_slave.vhd,
+    rtl/tcdm_slave.vhd,
+    rtl/edram_array.vhd,
+    rtl/edram_bank.vhd,
+    rtl/edram_ctrl.vhd,
+    rtl/edram_emu.vhd,
+  ]
diff --git a/ips/pulp_soc/rtl/components/pulp_interfaces.sv b/ips/pulp_soc/rtl/components/pulp_interfaces.sv
--- a/ips/pulp_soc/rtl/components/pulp_interfaces.sv
+++ b/ips/pulp_soc/rtl/components/pulp_interfaces.sv
@@ -291,6 +291,32 @@ interface UNICAD_MEM_BUS_32;
 endinterface
 
 
+//**********************************************************
+//**************** EDRAM_MEM_BUS_32 ************************
+//**********************************************************
+interface EDRAM_MEM_BUS_32;
+   logic [31:0] wdata;
+   logic [31:0] add;
+   logic        csn;
+   logic        wen;
+   logic [3:0]  be;
+   logic        gnt;
+   logic [31:0] rdata;
+
+   modport Master
+   (
+      output wdata, output add, output csn,
+      output wen, output be, input gnt, input rdata
+   );
+
+   modport Slave
+   (
+      input wdata, input add, input csn,
+      input wen, input be, output gnt, output rdata
+   );
+endinterface
+
+
 //********************************************************
 //******************** TCDM BUS **************************
 //********************************************************
diff --git a/ips/pulp_soc/rtl/pulp_soc/edram_emu_wrap.sv b/ips/pulp_soc/rtl/pulp_soc/edram_emu_wrap.sv
new file mode 100644
--- /dev/null
+++ b/ips/pulp_soc/rtl/pulp_soc/edram_emu_wrap.sv
@@ -0,0 +1,156 @@
+module edram_emu_wrap #(
+    parameter NB_BANKS,
+    parameter BANK_SRAM_SIZE,
+    parameter BANK_EDRAM_SIZE,
+    parameter MEM_ADDR_WIDTH,
+    parameter APB_ADDR_WIDTH
+) (
+    input logic            clk_i,
+    input logic            clk_ext_i,
+    input logic            rst_ni,
+    output logic           clk_en_o,
+    EDRAM_MEM_BUS_32.Slave mem_slave[NB_BANKS-1:0],
+    APB_BUS.Slave          apb_slave
+);
+
+    localparam SRAM_AWIDTH  = $clog2(BANK_SRAM_SIZE);
+    localparam EDRAM_AWIDTH = $clog2(BANK_EDRAM_SIZE) + 2;
+
+    genvar i;
+
+    logic [NB_BANKS-1:0]              asel;
+    logic [NB_BANKS-1:0]              asel_q;
+    logic [NB_BANKS-1:0][32-1:0]      sram_rdata;
+    logic [NB_BANKS*32-1:0]           edram_wdata;
+    logic [NB_BANKS*EDRAM_AWIDTH-1:0] edram_addr;
+    logic [NB_BANKS-1:0]              edram_en;
+    logic [NB_BANKS-1:0]              edram_rnw;
+    logic [NB_BANKS*4-1:0]            edram_be;
+    logic [NB_BANKS-1:0]              edram_gnt;
+    logic [NB_BANKS*32-1:0]           edram_rdata;
+
+    generate
+        for (i=0; i<NB_BANKS; i++)
+        begin
+            assign asel[i] = mem_slave[i].add[MEM_ADDR_WIDTH-1:0] >= BANK_SRAM_SIZE;
+
+            always_ff @(posedge clk_ext_i, negedge rst_ni)
+            begin
+                if (rst_ni == 1'b0) begin
+                    asel_q <= '0;
+                end
+                else begin
+                    asel_q <= asel;
+                end
+            end
+        end
+    endgenerate
+
+    generate
+        for (i=0; i<NB_BANKS; i++)
+        begin
+            always_comb
+            begin
+                if (asel[i] == 1'b0)
+                    begin
+                        mem_slave[i].gnt = 1'b1;
+                    end
+                else
+                    begin
+                        mem_slave[i].gnt = edram_gnt[i];
+                    end
+            end
+        end
+    endgenerate
+
+    generate
+        for (i=0; i<NB_BANKS; i++)
+        begin
+            always_comb
+            begin
+                if (asel_q[i] == 1'b0)
+                    begin
+                        mem_slave[i].rdata <= sram_rdata[i];
+                    end
+                else
+                    begin
+                        mem_slave[i].rdata <= edram_rdata[(i+1)*32-1:i*32];
+                    end
+            end
+        end
+    endgenerate
+
+    generate
+        for (i=0; i<NB_BANKS; i++)
+        begin
+            `ifndef PULP_FPGA_EMUL
+            generic_memory #(
+                .ADDR_WIDTH ( SRAM_AWIDTH ),
+                .DATA_WIDTH ( 32          )
+            ) bank_sram_pri1_i (
+                .CLK   ( clk_ext_i                         ),
+                .INITN ( 1'b1                              ),
+                .CEN   ( mem_slave[i].csn | asel[i]        ),
+                .BEN   (~mem_slave[i].be                   ),
+                .WEN   ( mem_slave[i].wen                  ),
+                .A     ( mem_slave[i].add[SRAM_AWIDTH-1:0] ),
+                .D     ( mem_slave[i].wdata                ),
+                .Q     ( sram_rdata[i]                     )
+            );
+            `else
+            fpga_interleaved_ram #(
+                .ADDR_WIDTH ( SRAM_AWIDTH )
+            ) bank_i (
+                .clk_i   (clk_ext_i                          ),
+                .rst_ni,
+                .csn_i   ( mem_slave[i].csn | asel[i]        ),
+                .wen_i   ( mem_slave[i].wen                  ),
+                .be_i    ( mem_slave[i].be                   ),
+                .addr_i  ( mem_slave[i].add[SRAM_AWIDTH-1:0] ),
+                .wdata_i ( mem_slave[i].wdata                ),
+                .rdata_o ( sram_rdata[i]                     )
+            );
+            `endif
+        end
+    endgenerate
+
+    generate
+        for (i=0; i<NB_BANKS; i++)
+        begin
+            assign edram_en[i]                                     =~mem_slave[i].csn & asel[i];
+            assign edram_addr[(i+1)*EDRAM_AWIDTH-1:i*EDRAM_AWIDTH] ={mem_slave[i].add[EDRAM_AWIDTH-3:0], 2'h0};
+            assign edram_rnw[i]                                    = mem_slave[i].wen;
+            assign edram_wdata[(i+1)*32-1:i*32]                    = mem_slave[i].wdata;
+            assign edram_be[(i+1)*4-1:i*4]                         = mem_slave[i].be;
+        end
+    endgenerate;
+
+    edram_emu #(
+        .NBANKS         ( NB_BANKS       ),
+        .AWIDTH         ( EDRAM_AWIDTH   ),
+        .DWIDTH_LOG     ( 5              ),
+        .APB_AWIDTH     ( APB_ADDR_WIDTH ),
+        .APB_DWIDTH_LOG ( 5              )
+    ) edram_emu_i (
+        .clk     ( clk_i                               ),
+        .clk_ext ( clk_ext_i                           ),
+        .rst_ext (~rst_ni                              ),
+        .clk_en  ( clk_en_o                            ),
+        .en      ( edram_en                            ),
+        .rnw     ( edram_rnw                           ),
+        .be      ( edram_be                            ),
+        .addr    ( edram_addr                          ),
+        .wdata   ( edram_wdata                         ),
+        .gnt     ( edram_gnt                           ),
+        .rdata   ( edram_rdata                         ),
+        .paddr   ( apb_slave.paddr[APB_ADDR_WIDTH-1:0] ),
+        .pwrite  ( apb_slave.pwrite                    ),
+        .pwdata  ( apb_slave.pwdata                    ),
+        .psel    ( apb_slave.psel                      ),
+        .penable ( apb_slave.penable                   ),
+        .prdata  ( apb_slave.prdata                    ),
+        .pready  ( apb_slave.pready                    ),
+        .pslverr ( apb_slave.pslverr                   )
+    );
+
+endmodule
diff --git a/ips/pulp_soc/rtl/pulp_soc/l2_ram_multi_bank.sv b/ips/pulp_soc/rtl/pulp_soc/l2_ram_multi_bank.sv
--- a/ips/pulp_soc/rtl/pulp_soc/l2_ram_multi_bank.sv
+++ b/ips/pulp_soc/rtl/pulp_soc/l2_ram_multi_bank.sv
@@ -11,28 +11,16 @@
 
 module l2_ram_multi_bank #(
    parameter NB_BANKS                   = 4,
-   parameter NB_BANKS_PRI               = 2,
    parameter BANK_SIZE                  = 29184,
-   parameter MEM_ADDR_WIDTH             = 14,
-   parameter MEM_ADDR_WIDTH_PRI         = 13
+   parameter MEM_ADDR_WIDTH             = 14
 ) (
    input logic             clk_i,
    input logic             rst_ni,
    input logic             init_ni,
    input logic             test_mode_i,
-   UNICAD_MEM_BUS_32.Slave mem_slave[NB_BANKS-1:0],
-   UNICAD_MEM_BUS_32.Slave mem_pri_slave[NB_BANKS_PRI-1:0]
-`ifdef QUENTIN_SCM
-   ,
-   UNICAD_MEM_BUS_32.Slave scm_data_slave,
-   UNICAD_MEM_BUS_32.Slave scm_instr_slave
-`endif
+   EDRAM_MEM_BUS_32.Slave  mem_slave[NB_BANKS-1:0]
 );
    //Used in testbenches
-   localparam  BANK_SIZE_PRI1       = 8192;
-   localparam  BANK_SIZE_PRI0_SRAM  = 6144;
-   localparam  BANK_SIZE_PRI0_SCM   = 2048;
-
    localparam  BANK_SIZE_INTL_SRAM  = 28672;
    localparam  BANK_SIZE_INTL_SCM   = 512;
 
@@ -71,104 +59,8 @@ module l2_ram_multi_bank #(
                       .rdata_o(mem_slave[i].rdata)
                       );
                  `endif
+                 assign mem_slave[i].gnt = 1'b1;
              end
       endgenerate
 
-      /*
-      As the PRI Banks are divided in SCM and SRAM,
-      a demux from the interconnect is needed.
-      The 8 KWord (32 KByte) Bank is
-      divided in 4Kword + 2Kword + 2Kword (16 Kbyte + 8 Kbyte + 8 Kbyte)
-      The first 2 Kword (address 0 to 2047) are for the SCM
-      */
-
-      // PRIVATE BANKS
-      /*
-         This model the hybrid SRAM and SCM configuration
-         that has been tape-out in the QUENTIN_SCM version
-      */
-      `ifndef PULP_FPGA_EMUL
-      generic_memory #(
-         .ADDR_WIDTH ( MEM_ADDR_WIDTH_PRI  ),
-         .DATA_WIDTH ( 32                  )
-      ) bank_sram_pri1_i (
-         .CLK   ( clk_i                      ),
-         .INITN ( 1'b1                       ),
-         .CEN   ( mem_pri_slave[1].csn       ),
-         .BEN   ( ~mem_pri_slave[1].be       ),
-         .WEN   ( mem_pri_slave[1].wen       ),
-         .A     ( mem_pri_slave[1].add[MEM_ADDR_WIDTH_PRI-1:0] ),
-         .D     ( mem_pri_slave[1].wdata     ),
-         .Q     ( mem_pri_slave[1].rdata     )
-      );
-      `else // !`ifndef PULP_FPGA_EMUL
-      fpga_private_ram #(.ADDR_WIDTH(MEM_ADDR_WIDTH_PRI)) bank_sram_pri1_i
-          (
-           .clk_i,
-           .rst_ni,
-           .csn_i(mem_pri_slave[1].csn),
-           .wen_i(mem_pri_slave[1].wen),
-           .be_i(mem_pri_slave[1].be),
-           .addr_i(mem_pri_slave[1].add[MEM_ADDR_WIDTH-1:0]),
-           .wdata_i(mem_pri_slave[1].wdata),
-           .rdata_o(mem_pri_slave[1].rdata)
-           );
-      `endif
-
-    `ifndef PULP_FPGA_EMUL
-      `ifdef QUENTIN_SCM
-      model_6144x32_2048x32scm bank_sram24k_scm8k_pri0_i (
-         .CLK      ( clk_i                      ),
-         .RSTN     ( rst_ni                     ),
-         .CEN      ( mem_pri_slave[0].csn       ),
-         .CEN_scm0 ( scm_data_slave.csn         ),
-         .CEN_scm1 ( scm_instr_slave.csn        ),
-
-         .BEN      ( ~mem_pri_slave[0].be       ),
-         .BEN_scm0 ( ~scm_data_slave.be         ),
-         .WEN      ( mem_pri_slave[0].wen       ),
-         .WEN_scm0 ( scm_data_slave.wen         ),
-         .WEN_scm1 ( scm_instr_slave.wen        ),
-
-         .A        ( mem_pri_slave[0].add[MEM_ADDR_WIDTH_PRI-1:0] ),
-         .A_scm0   ( scm_data_slave.add[MEM_ADDR_WIDTH_PRI-1:2]   ),
-         .A_scm1   ( scm_instr_slave.add[MEM_ADDR_WIDTH_PRI-1:2]  ),
-
-         .D        ( mem_pri_slave[0].wdata     ),
-         .D_scm0   ( scm_data_slave.wdata       ),
-
-         .Q        ( mem_pri_slave[0].rdata     ),
-         .Q_scm0   ( scm_data_slave.rdata       ),
-         .Q_scm1   ( scm_instr_slave.rdata      )
-      );
-      `else
-      generic_memory #(
-         .ADDR_WIDTH ( MEM_ADDR_WIDTH_PRI  ),
-         .DATA_WIDTH ( 32                  )
-      ) bank_sram_pri0_i (
-         .CLK   ( clk_i                      ),
-         .INITN ( 1'b1                       ),
-         .CEN   ( mem_pri_slave[0].csn       ),
-         .BEN   ( ~mem_pri_slave[0].be       ),
-         .WEN   ( mem_pri_slave[0].wen       ),
-         .A     ( mem_pri_slave[0].add[MEM_ADDR_WIDTH_PRI-1:0] ),
-         .D     ( mem_pri_slave[0].wdata     ),
-         .Q     ( mem_pri_slave[0].rdata     )
-      );
-      `endif // !`ifdef QUENTIN_SCM
-    `else // !`ifndef PULP_FPGA_EMUL
-    fpga_private_ram #(.ADDR_WIDTH(MEM_ADDR_WIDTH_PRI)) bank_sram_pri0_i
-        (
-         .clk_i,
-         .rst_ni,
-         .csn_i(mem_pri_slave[0].csn),
-         .wen_i(mem_pri_slave[0].wen),
-         .be_i(mem_pri_slave[0].be),
-         .addr_i(mem_pri_slave[0].add[MEM_ADDR_WIDTH-1:0]),
-         .wdata_i(mem_pri_slave[0].wdata),
-         .rdata_o(mem_pri_slave[0].rdata)
-         );
-
-    `endif
-
 endmodule // l2_ram_multi_bank
diff --git a/ips/pulp_soc/rtl/pulp_soc/l2_ram_multi_bank_pri.sv b/ips/pulp_soc/rtl/pulp_soc/l2_ram_multi_bank_pri.sv
new file mode 100644
--- /dev/null
+++ b/ips/pulp_soc/rtl/pulp_soc/l2_ram_multi_bank_pri.sv
@@ -0,0 +1,130 @@
+// Copyright 2018 ETH Zurich and University of Bologna.
+// Copyright and related rights are licensed under the Solderpad Hardware
+// License, Version 0.51 (the "License"); you may not use this file except in
+// compliance with the License.  You may obtain a copy of the License at
+// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
+// or agreed to in writing, software, hardware and materials distributed under
+// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+// CONDITIONS OF ANY KIND, either express or implied. See the License for the
+// specific language governing permissions and limitations under the License.
+
+
+module l2_ram_multi_bank_pri #(
+   parameter NB_BANKS_PRI               = 2,
+   parameter MEM_ADDR_WIDTH_PRI         = 13
+) (
+   input logic             clk_i,
+   input logic             rst_ni,
+   input logic             init_ni,
+   input logic             test_mode_i,
+   UNICAD_MEM_BUS_32.Slave mem_pri_slave[NB_BANKS_PRI-1:0]
+`ifdef QUENTIN_SCM
+   ,
+   UNICAD_MEM_BUS_32.Slave scm_data_slave,
+   UNICAD_MEM_BUS_32.Slave scm_instr_slave
+`endif
+);
+   //Used in testbenches
+   localparam  BANK_SIZE_PRI1       = 8192;
+   localparam  BANK_SIZE_PRI0_SRAM  = 6144;
+   localparam  BANK_SIZE_PRI0_SCM   = 2048;
+
+
+      /*
+      As the PRI Banks are divided in SCM and SRAM,
+      a demux from the interconnect is needed.
+      The 8 KWord (32 KByte) Bank is
+      divided in 4Kword + 2Kword + 2Kword (16 Kbyte + 8 Kbyte + 8 Kbyte)
+      The first 2 Kword (address 0 to 2047) are for the SCM
+      */
+
+      // PRIVATE BANKS
+      /*
+         This model the hybrid SRAM and SCM configuration
+         that has been tape-out in the QUENTIN_SCM version
+      */
+      `ifndef PULP_FPGA_EMUL
+      generic_memory #(
+         .ADDR_WIDTH ( MEM_ADDR_WIDTH_PRI  ),
+         .DATA_WIDTH ( 32                  )
+      ) bank_sram_pri1_i (
+         .CLK   ( clk_i                      ),
+         .INITN ( 1'b1                       ),
+         .CEN   ( mem_pri_slave[1].csn       ),
+         .BEN   ( ~mem_pri_slave[1].be       ),
+         .WEN   ( mem_pri_slave[1].wen       ),
+         .A     ( mem_pri_slave[1].add[MEM_ADDR_WIDTH_PRI-1:0] ),
+         .D     ( mem_pri_slave[1].wdata     ),
+         .Q     ( mem_pri_slave[1].rdata     )
+      );
+      `else // !`ifndef PULP_FPGA_EMUL
+      fpga_private_ram #(.ADDR_WIDTH(MEM_ADDR_WIDTH_PRI)) bank_sram_pri1_i
+          (
+           .clk_i,
+           .rst_ni,
+           .csn_i(mem_pri_slave[1].csn),
+           .wen_i(mem_pri_slave[1].wen),
+           .be_i(mem_pri_slave[1].be),
+           .addr_i(mem_pri_slave[1].add[MEM_ADDR_WIDTH-1:0]),
+           .wdata_i(mem_pri_slave[1].wdata),
+           .rdata_o(mem_pri_slave[1].rdata)
+           );
+      `endif
+
+    `ifndef PULP_FPGA_EMUL
+      `ifdef QUENTIN_SCM
+      model_6144x32_2048x32scm bank_sram24k_scm8k_pri0_i (
+         .CLK      ( clk_i                      ),
+         .RSTN     ( rst_ni                     ),
+         .CEN      ( mem_pri_slave[0].csn       ),
+         .CEN_scm0 ( scm_data_slave.csn         ),
+         .CEN_scm1 ( scm_instr_slave.csn        ),
+
+         .BEN      ( ~mem_pri_slave[0].be       ),
+         .BEN_scm0 ( ~scm_data_slave.be         ),
+         .WEN      ( mem_pri_slave[0].wen       ),
+         .WEN_scm0 ( scm_data_slave.wen         ),
+         .WEN_scm1 ( scm_instr_slave.wen        ),
+
+         .A        ( mem_pri_slave[0].add[MEM_ADDR_WIDTH_PRI-1:0] ),
+         .A_scm0   ( scm_data_slave.add[MEM_ADDR_WIDTH_PRI-1:2]   ),
+         .A_scm1   ( scm_instr_slave.add[MEM_ADDR_WIDTH_PRI-1:2]  ),
+
+         .D        ( mem_pri_slave[0].wdata     ),
+         .D_scm0   ( scm_data_slave.wdata       ),
+
+         .Q        ( mem_pri_slave[0].rdata     ),
+         .Q_scm0   ( scm_data_slave.rdata       ),
+         .Q_scm1   ( scm_instr_slave.rdata      )
+      );
+      `else
+      generic_memory #(
+         .ADDR_WIDTH ( MEM_ADDR_WIDTH_PRI  ),
+         .DATA_WIDTH ( 32                  )
+      ) bank_sram_pri0_i (
+         .CLK   ( clk_i                      ),
+         .INITN ( 1'b1                       ),
+         .CEN   ( mem_pri_slave[0].csn       ),
+         .BEN   ( ~mem_pri_slave[0].be       ),
+         .WEN   ( mem_pri_slave[0].wen       ),
+         .A     ( mem_pri_slave[0].add[MEM_ADDR_WIDTH_PRI-1:0] ),
+         .D     ( mem_pri_slave[0].wdata     ),
+         .Q     ( mem_pri_slave[0].rdata     )
+      );
+      `endif // !`ifdef QUENTIN_SCM
+    `else // !`ifndef PULP_FPGA_EMUL
+    fpga_private_ram #(.ADDR_WIDTH(MEM_ADDR_WIDTH_PRI)) bank_sram_pri0_i
+        (
+         .clk_i,
+         .rst_ni,
+         .csn_i(mem_pri_slave[0].csn),
+         .wen_i(mem_pri_slave[0].wen),
+         .be_i(mem_pri_slave[0].be),
+         .addr_i(mem_pri_slave[0].add[MEM_ADDR_WIDTH-1:0]),
+         .wdata_i(mem_pri_slave[0].wdata),
+         .rdata_o(mem_pri_slave[0].rdata)
+         );
+
+    `endif
+
+endmodule // l2_ram_multi_bank_pri
diff --git a/ips/pulp_soc/rtl/pulp_soc/periph_bus_wrap.sv b/ips/pulp_soc/rtl/pulp_soc/periph_bus_wrap.sv
--- a/ips/pulp_soc/rtl/pulp_soc/periph_bus_wrap.sv
+++ b/ips/pulp_soc/rtl/pulp_soc/periph_bus_wrap.sv
@@ -29,6 +29,10 @@ module periph_bus_wrap #(
     APB_BUS.Master timer_master,
     APB_BUS.Master hwpe_master,
     APB_BUS.Master stdout_master
+`ifdef PULP_EDRAM_EMUL
+    ,
+    APB_BUS.Master edram_master
+`endif
 );
 
     localparam NB_MASTER = `NB_MASTER;
@@ -94,6 +98,12 @@ module periph_bus_wrap #(
     assign s_start_addr[10] = `DEBUG_START_ADDR;
     assign s_end_addr[10]   = `DEBUG_END_ADDR;
 
+`ifdef PULP_EDRAM_EMUL
+    `APB_ASSIGN_MASTER(s_masters[11], edram_master);
+    assign s_start_addr[11] = `EDRAM_START_ADDR;
+    assign s_end_addr[11]   = `EDRAM_END_ADDR;
+`endif
+
     //********************************************************
     //**************** SOC BUS *******************************
     //********************************************************
diff --git a/ips/pulp_soc/rtl/pulp_soc/pulp_soc.sv b/ips/pulp_soc/rtl/pulp_soc/pulp_soc.sv
--- a/ips/pulp_soc/rtl/pulp_soc/pulp_soc.sv
+++ b/ips/pulp_soc/rtl/pulp_soc/pulp_soc.sv
@@ -234,7 +234,13 @@ module pulp_soc
     localparam FLL_ADDR_WIDTH        = 32;
     localparam FLL_DATA_WIDTH        = 32;
     localparam NB_L2_BANKS           = `NB_L2_CHANNELS;
+`ifndef PULP_EDRAM_EMUL
     localparam L2_BANK_SIZE          = 29184;            // in 32-bit words
+`else
+    localparam L2_BANK_SRAM_SIZE     = 65536;            // in 32-bit words
+    localparam L2_BANK_EDRAM_SIZE    = 32768;            // in 32-bit words
+    localparam L2_BANK_SIZE          = L2_BANK_SRAM_SIZE + L2_BANK_EDRAM_SIZE;
+`endif
     localparam L2_MEM_ADDR_WIDTH     = $clog2(L2_BANK_SIZE * NB_L2_BANKS) - $clog2(NB_L2_BANKS);    // 2**L2_MEM_ADDR_WIDTH rows (64bit each) in L2 --> TOTAL L2 SIZE = 8byte * 2^L2_MEM_ADDR_WIDTH
     localparam NB_L2_BANKS_PRI       = 2;
     localparam L2_BANK_SIZE_PRI      = 8192;             // in 32-bit words
@@ -311,7 +317,11 @@ module pulp_soc
 
     logic                  s_periph_clk;
     logic                  s_periph_rstn;
+    logic                  s_main_clk;
     logic                  s_soc_clk;
+`ifdef PULP_EDRAM_EMUL
+    logic                  s_soc_clk_en;
+`endif
     logic                  s_soc_rstn;
     logic                  s_cluster_clk;
     logic                  s_cluster_rstn;
@@ -358,6 +368,9 @@ module pulp_soc
     APB_BUS                s_apb_eu_bus ();
     APB_BUS                s_apb_hwpe_bus ();
     APB_BUS                s_apb_debug_bus();
+`ifdef PULP_EDRAM_EMUL
+    APB_BUS                s_apb_edram_bus();
+`endif
 
     AXI_BUS_ASYNC #(
         .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),
@@ -406,7 +419,7 @@ module pulp_soc
 
     UNICAD_MEM_BUS_32 s_mem_rom_bus ();
 
-    UNICAD_MEM_BUS_32  s_mem_l2_bus[NB_L2_BANKS-1:0]();
+    EDRAM_MEM_BUS_32   s_mem_l2_bus[NB_L2_BANKS-1:0]();
     UNICAD_MEM_BUS_32  s_mem_l2_pri_bus[NB_L2_BANKS_PRI-1:0]();
 `ifdef QUENTIN_SCM
     UNICAD_MEM_BUS_32 s_scm_l2_data_bus ();
@@ -482,18 +495,43 @@ module pulp_soc
     //********************* SOC L2 RAM ***********************
     //********************************************************
 
+`ifndef PULP_EDRAM_EMUL
     l2_ram_multi_bank #(
         .MEM_ADDR_WIDTH        ( L2_MEM_ADDR_WIDTH     ),
         .NB_BANKS              ( NB_L2_BANKS           ),
-        .BANK_SIZE             ( L2_BANK_SIZE          ),
-        .MEM_ADDR_WIDTH_PRI    ( L2_MEM_ADDR_WIDTH_PRI ),
-        .NB_BANKS_PRI          ( NB_L2_BANKS_PRI       )
+        .BANK_SIZE             ( L2_BANK_SIZE          )
     ) l2_ram_i (
         .clk_i           ( s_soc_clk          ),
         .rst_ni          ( s_soc_rstn         ),
         .init_ni         ( 1'b1               ),
         .test_mode_i     ( dft_test_mode_i    ),
+        .mem_slave       ( s_mem_l2_bus       )
+    );
+`else // !`ifndef PULP_EDRAM_EMUL
+    edram_emu_wrap #(
+        .NB_BANKS              ( NB_L2_BANKS           ),
+        .BANK_SRAM_SIZE        ( L2_BANK_SRAM_SIZE     ),
+        .BANK_EDRAM_SIZE       ( L2_BANK_EDRAM_SIZE    ),
+        .MEM_ADDR_WIDTH        ( L2_MEM_ADDR_WIDTH     ),
+        .APB_ADDR_WIDTH        ( 18                    )
+    ) edram_emu_wrap_i (
+        .clk_i           ( s_main_clk         ),
+        .clk_ext_i       ( s_soc_clk          ),
+        .rst_ni          ( s_soc_rstn         ),
+        .clk_en_o        ( s_soc_clk_en       ),
         .mem_slave       ( s_mem_l2_bus       ),
+        .apb_slave       ( s_apb_edram_bus    )
+    );
+`endif
+
+    l2_ram_multi_bank_pri #(
+        .MEM_ADDR_WIDTH_PRI    ( L2_MEM_ADDR_WIDTH_PRI ),
+        .NB_BANKS_PRI          ( NB_L2_BANKS_PRI       )
+    ) l2_ram_pri_i (
+        .clk_i           ( s_soc_clk          ),
+        .rst_ni          ( s_soc_rstn         ),
+        .init_ni         ( 1'b1               ),
+        .test_mode_i     ( dft_test_mode_i    ),
         .mem_pri_slave   ( s_mem_l2_pri_bus   )
 `ifdef QUENTIN_SCM
         ,
@@ -555,6 +593,9 @@ module pulp_soc
         .apb_eu_master          ( s_apb_eu_bus           ),
         .apb_debug_master       ( s_apb_debug_bus        ),
         .apb_hwpe_master        ( s_apb_hwpe_bus         ),
+`ifdef PULP_EDRAM_EMUL
+        .edram_master           ( s_apb_edram_bus        ),
+`endif
 
         .l2_rx_master           ( s_lint_udma_rx_bus     ),
         .l2_tx_master           ( s_lint_udma_tx_bus     ),
@@ -761,10 +802,21 @@ module pulp_soc
         .cluster_fll_slave_r_data_o ( s_cluster_fll_master.r_data   ),
         .cluster_fll_slave_lock_o   ( s_cluster_fll_master.lock     ),
 
-        .clk_soc_o                  ( s_soc_clk                     ),
+        .clk_soc_o                  ( s_main_clk                    ),
         .clk_per_o                  ( s_periph_clk                  )
     );
 
+`ifndef PULP_EDRAM_EMUL
+    assign s_soc_clk = s_main_clk;
+`else
+    pulp_clock_gating i_pulp_clock_gating (
+        .clk_i     ( s_main_clk   ),
+        .en_i      ( s_soc_clk_en ),
+        .test_en_i ( 1'b0         ),
+        .clk_o     ( s_soc_clk    )
+    );
+`endif
+
     soc_interconnect_wrap #(
         .N_L2_BANKS         ( NB_L2_BANKS           ),
         .ADDR_MEM_WIDTH     ( L2_MEM_ADDR_WIDTH     ),
diff --git a/ips/pulp_soc/rtl/pulp_soc/soc_interconnect.sv b/ips/pulp_soc/rtl/pulp_soc/soc_interconnect.sv
--- a/ips/pulp_soc/rtl/pulp_soc/soc_interconnect.sv
+++ b/ips/pulp_soc/rtl/pulp_soc/soc_interconnect.sv
@@ -43,6 +43,7 @@ module soc_interconnect #(
     output logic [N_L2_BANKS-1:0]                               L2_CEN_o,
     output logic [N_L2_BANKS-1:0]                               L2_WEN_o,
     output logic [N_L2_BANKS-1:0]     [BE_WIDTH-1:0]            L2_BE_o,
+    input  logic [N_L2_BANKS-1:0]                               L2_GNT_i,
     input  logic [N_L2_BANKS-1:0]     [DATA_WIDTH-1:0]          L2_Q_i,
     //RISC DATA PORT
     input  logic                                                FC_DATA_req_i,
@@ -261,7 +262,7 @@ module soc_interconnect #(
     localparam logic [N_PERIPHS-1:0][ADDR_WIDTH-1:0] PER_END_ADDR   = { 32'h1C01_0000, 32'h1C00_8000, 32'h1A04_0000,  32'h1040_0000, 32'h1A40_0000};
 
     localparam logic [ADDR_WIDTH-1:0] TCDM_START_ADDR = {32'h1C01_0000}; // Start of L2 interleaved
-    localparam logic [ADDR_WIDTH-1:0] TCDM_END_ADDR   = {32'h1C08_2000}; // END of L2 interleaved
+    localparam logic [ADDR_WIDTH-1:0] TCDM_END_ADDR   = {32'h1C19_0000}; // END of L2 interleaved
 
     logic [N_MASTER_32-1:0]                           FC_data_req_INT_32;
     logic [N_MASTER_32-1:0] [ADDR_WIDTH - 1:0]        FC_data_add_INT_32;
@@ -336,6 +337,7 @@ module soc_interconnect #(
     logic [N_L2_BANKS-1:0]                            TCDM_data_wen_TO_MEM;
     logic [N_L2_BANKS-1:0][BE_WIDTH-1:0]              TCDM_data_be_TO_MEM;
     logic [N_L2_BANKS-1:0][ID_WIDTH-1:0]              TCDM_data_ID_TO_MEM;
+    logic [N_L2_BANKS-1:0]                            TCDM_data_gnt_TO_MEM;
     logic [N_L2_BANKS-1:0][DATA_WIDTH-1:0]            TCDM_data_rdata_TO_MEM;
     logic [N_L2_BANKS-1:0]                            TCDM_data_rvalid_TO_MEM;
     logic [N_L2_BANKS-1:0][ID_WIDTH-1:0]              TCDM_data_rID_TO_MEM;
@@ -467,6 +469,7 @@ module soc_interconnect #(
         .data_wdata_o   ( TCDM_data_wdata_TO_MEM            ),
         .data_be_o      ( TCDM_data_be_TO_MEM               ),
         .data_ID_o      ( TCDM_data_ID_TO_MEM               ),
+        .data_gnt_i     ( TCDM_data_gnt_TO_MEM              ),
 
         .data_r_rdata_i ( TCDM_data_rdata_TO_MEM            ),
         .data_r_valid_i ( TCDM_data_rvalid_TO_MEM           ),
@@ -662,6 +665,7 @@ module soc_interconnect #(
             L2_CEN_o[i] = ~TCDM_data_req_TO_MEM[i];
             L2_WEN_o[i] =  TCDM_data_wen_TO_MEM[i];
             L2_BE_o[i]  =  TCDM_data_be_TO_MEM[i];
+            TCDM_data_gnt_TO_MEM[i]   = L2_GNT_i[i];
             TCDM_data_rdata_TO_MEM[i] = L2_Q_i[i];
         end
     end
@@ -676,7 +680,7 @@ module soc_interconnect #(
         end
         else begin
             for (int unsigned  i=0;i<N_L2_BANKS;i++) begin
-                if(TCDM_data_req_TO_MEM[i]) begin
+                if(TCDM_data_req_TO_MEM[i] & TCDM_data_gnt_TO_MEM[i]) begin
                     TCDM_data_rID_TO_MEM[i]       <= TCDM_data_ID_TO_MEM[i];
                     TCDM_data_rvalid_TO_MEM[i]    <= 1'b1;
                 end
diff --git a/ips/pulp_soc/rtl/pulp_soc/soc_interconnect_wrap.sv b/ips/pulp_soc/rtl/pulp_soc/soc_interconnect_wrap.sv
--- a/ips/pulp_soc/rtl/pulp_soc/soc_interconnect_wrap.sv
+++ b/ips/pulp_soc/rtl/pulp_soc/soc_interconnect_wrap.sv
@@ -37,7 +37,7 @@ module soc_interconnect_wrap #(
     AXI_BUS.Slave            axi_from_cluster,
     AXI_BUS.Master           axi_to_cluster,
     APB_BUS.Master           apb_periph_bus,
-    UNICAD_MEM_BUS_32.Master mem_l2_bus[N_L2_BANKS-1:0],
+    EDRAM_MEM_BUS_32.Master  mem_l2_bus[N_L2_BANKS-1:0],
     UNICAD_MEM_BUS_32.Master mem_l2_pri_bus[N_L2_BANKS_PRI-1:0],
     UNICAD_MEM_BUS_32.Master mem_rom_bus
 );
@@ -47,6 +47,7 @@ module soc_interconnect_wrap #(
     logic [N_L2_BANKS-1:0]                             mem_csn;
     logic [N_L2_BANKS-1:0]                             mem_wen;
     logic [N_L2_BANKS-1:0][3:0]                        mem_be;
+    logic [N_L2_BANKS-1:0]                             mem_gnt;
     logic [N_L2_BANKS-1:0][31:0]                       mem_rdata;
 
     logic [N_L2_BANKS_PRI-1:0][31:0]                   mem_pri_wdata;
@@ -91,6 +92,7 @@ module soc_interconnect_wrap #(
             assign mem_l2_bus[i].wen                     =  mem_wen[i];
             assign mem_l2_bus[i].wdata                   =  mem_wdata[i];
             assign mem_l2_bus[i].be                      =  mem_be[i];
+            assign mem_gnt[i]                            =  mem_l2_bus[i].gnt;
             assign mem_rdata[i]                          =  mem_l2_bus[i].rdata;
         end
 
@@ -133,6 +135,7 @@ module soc_interconnect_wrap #(
         .L2_CEN_o               ( mem_csn                                       ),
         .L2_WEN_o               ( mem_wen                                       ),
         .L2_BE_o                ( mem_be                                        ),
+        .L2_GNT_i               ( mem_gnt                                       ),
         .L2_Q_i                 ( mem_rdata                                     ),
 
         .L2_pri_D_o             ( mem_pri_wdata                                 ),
diff --git a/ips/pulp_soc/rtl/pulp_soc/soc_peripherals.sv b/ips/pulp_soc/rtl/pulp_soc/soc_peripherals.sv
--- a/ips/pulp_soc/rtl/pulp_soc/soc_peripherals.sv
+++ b/ips/pulp_soc/rtl/pulp_soc/soc_peripherals.sv
@@ -46,6 +46,9 @@ module soc_peripherals #(
     APB_BUS.Master                     apb_eu_master,
     APB_BUS.Master                     apb_hwpe_master,
     APB_BUS.Master                     apb_debug_master,
+`ifdef PULP_EDRAM_EMUL
+    APB_BUS.Master                     edram_master,
+`endif
 
     // FABRIC CONTROLLER MASTER REFILL PORT
     XBAR_TCDM_BUS.Master               l2_rx_master,
@@ -261,6 +264,10 @@ module soc_peripherals #(
         .hwpe_master         ( apb_hwpe_master    ),
         .timer_master        ( s_apb_timer_bus    ),
         .stdout_master       ( s_stdout_bus       )
+`ifdef PULP_EDRAM_EMUL
+        ,
+        .edram_master        ( edram_master       )
+`endif
     );
 
     `ifdef SYNTHESIS
diff --git a/ips/pulp_soc/src_files.yml b/ips/pulp_soc/src_files.yml
--- a/ips/pulp_soc/src_files.yml
+++ b/ips/pulp_soc/src_files.yml
@@ -6,6 +6,8 @@ pulp_soc:
     rtl/pulp_soc/soc_interconnect.sv,
     rtl/pulp_soc/boot_rom.sv,
     rtl/pulp_soc/l2_ram_multi_bank.sv,
+    rtl/pulp_soc/l2_ram_multi_bank_pri.sv,
+    rtl/pulp_soc/edram_emu_wrap.sv,
     rtl/pulp_soc/lint_jtag_wrap.sv,
     rtl/pulp_soc/periph_bus_wrap.sv,
     rtl/pulp_soc/soc_clk_rst_gen.sv,
diff --git a/rtl/includes/periph_bus_defines.sv b/rtl/includes/periph_bus_defines.sv
--- a/rtl/includes/periph_bus_defines.sv
+++ b/rtl/includes/periph_bus_defines.sv
@@ -14,8 +14,14 @@
  *
  */
 
+`include "pulp_soc_defines.sv"
+
 // SOC PERIPHERALS APB BUS PARAMETRES
+`ifndef PULP_EDRAM_EMUL
 `define NB_MASTER  11
+`else
+`define NB_MASTER  12
+`endif
 
 // MASTER PORT TO FLL
 `define FLL_START_ADDR           32'h1A10_0000
@@ -59,6 +65,10 @@
 `define DUMMY_START_ADDR         32'h1A12_0000
 `define DUMMY_END_ADDR           32'h1A12_0008
 
+`ifdef PULP_EDRAM_EMUL
+`define EDRAM_START_ADDR         32'h1A18_0000
+`define EDRAM_END_ADDR           32'h1A1C_0000
+`endif
 
 `define APB_ASSIGN_SLAVE(lhs, rhs)     \
     assign lhs.paddr    = rhs.paddr;   \
diff --git a/rtl/includes/pulp_soc_defines.sv b/rtl/includes/pulp_soc_defines.sv
--- a/rtl/includes/pulp_soc_defines.sv
+++ b/rtl/includes/pulp_soc_defines.sv
@@ -31,6 +31,9 @@
 `define USE_L2_MULTIBANK
 `define NB_L2_CHANNELS 4
 
+// Use edram emulator
+`define PULP_EDRAM_EMUL
+
 // JTAG
 `define DMI_JTAG_IDCODE 32'h249511C3
 
